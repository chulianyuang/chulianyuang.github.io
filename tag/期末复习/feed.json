{
    "version": "https://jsonfeed.org/version/1",
    "title": "welcome to my world • All posts by \"期末复习\" tag",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2023/05/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%A0%E9%A2%98%E6%B1%87%E6%80%BB/",
            "url": "http://example.com/2023/05/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%A0%E9%A2%98%E6%B1%87%E6%80%BB/",
            "title": "数据结构与算法习题汇总",
            "date_published": "2023-05-25T05:00:35.000Z",
            "content_html": "<h1 id=\"第一章-数据结构概述\"><a class=\"markdownIt-Anchor\" href=\"#第一章-数据结构概述\">#</a> 第一章 数据结构概述</h1>\n<p>基本概念与术语</p>\n<ol>\n<li>\n<p>数据：数据是对客观事物的符号表示，在计算机科学中是指所有能输入到计算机中并被<br>\n计算机程序所处理的符号的总称。</p>\n</li>\n<li>\n<p>数据元素：数据元素是数据的基本单位，是数据这个集合中的个体，也称之为元素，结点，顶点记录。<br>\n（补充：一个数据元素可由若干个 数据项组成。数据项是数据的不可分割的最小单位。）</p>\n</li>\n<li>\n<p>数据对象：数据对象是具有相同性质的数据元素的集合，是数据的一个子集。（有时候也<br>\n叫做属性。</p>\n</li>\n<li>\n<p>数据结构：数据结构是相互之间存在一种或多种特定关系的数据元素的集合。<br>\n（1）数据的逻辑结构是指数据元素之间存在的固有逻辑关系，常称为数<br>\n据结构。<br>\n（2）数据的逻辑结构是从数据元素之间存在的逻辑关系上描述数据与数据的存储无关，是<br>\n独立于计算机的。<br>\n依据数据元素之间的关系，可以把数据的逻辑结构分成以下几种：</p>\n</li>\n</ol>\n<p>集合：数据中的数据元素之间除了 “同属于一个集合 “的关系以外，没有其他关系。<br>\n线性结构：结构中的数据元素之间存在 “一对一 “的关系。若结构为非空集合，则除了第<br>\n一个元素之外，和最后一个元素之外，其他每个元素都只有一个直接前驱和一个直接后继。<br>\n树形结构：结构中的数据元素之间存在 “一对多 “的关系。若数据为非空集，则除了第一<br>\n个元素（根）之外，其它 每个数据元素都只有一个直接前驱，以及多个或零个 直<br>\n接后继。<br>\n图状结构：</p>\n<p>（1）结构中的数据元素存在 “多对多” 的关系。若结构为非空集，折每个数据可有<br>\n多个（或零个）直接后继。<br>\n（2）数据的存储结构：数据元素及其关系在计算机内的表示称为数据的存储结构。<br>\n想要计算机处理数据，就必须把数据的逻辑结构映射为数据的存储结构。<br>\n逻辑结构可以映射为以下两种存储结构：<br>\n顺序存储结构：把逻辑上相邻的数据元素存储在物理位置也相邻的存储单元中，借助元素<br>\n在存储器中的相对位置来表示数据之间的逻辑关系。<br>\n链式存储结构：借助指针表达数据元素之间的逻辑关系。不要求逻辑上相邻的数据元素物<br>\n理位置上也相邻。<br>\n时间复杂度分析：<br>\n1. 常量阶：算法的时间复杂度与问题规模 n 无关系 T (n)=O (1)<br>\n 2. 线性阶：算法的时间复杂度与问题规模 n 成线性关系 T (n)=O (n)<br>\n 3. 平方阶和立方阶：一般为 循环的嵌套，循环体最后条件为 i++<br>\n 时间复杂度的大小比较：<br>\nO(1)&lt; O(log 2 n)&lt; O(n )&lt; O(n log 2 n)&lt; O(n2)&lt; O(n3)&lt; O(2 n )&lt;O(n!)&lt;O(n n)<br>\n 6. 算法与程序：<br>\n（1）算法的 5 个特性<br>\n 1、 输入：有零个或多个输入<br>\n 2、 输出：有一个或多个输出<br>\n 3、有穷性：要求序列中的指令是有限的；每条指令的执行包含有限的工作量；整个指令序<br>\n列的执行在有限的时间内结束。（程序与算法的区别在于，程序不需要有有穷性）<br>\n4、确定性：算法中的每一个步骤都必须是确定的，而不应当含糊、模棱两可。没有歧义。<br>\n5、可行性：算法中的每一个步骤都应当能被有效的执行，并得到确定的结果。<br>\n（2）. 算法设计的要求：<br>\n1、正确性（达到预期效果，满足问题需求）<br>\n2、健壮性（能处理合法数据，也能对不合法的数据作出反应，不会产生不<br>\n可预期的后果）<br>\n3、可读性（要求算法易于理解，便于分析）<br>\n4、可修改可扩展性<br>\n 5、高效率（较好的时空性能 ）<br>\n补充内容：<br>\n1、名词解释：数据结构、二元组<br>\n数据结构就是相互之间存在一种或多种特定关系的数据元素的集合。<br>\n二元组就是一种用来表示某个数据对象以及各个元素之间关系的有限集合。<br>\n2、根据数据元素之间关系的不同，数据的逻辑结构可以分为集合、线性结构、树形结构和<br>\n图状结构四种类型。<br>\n3、常见的数据存储结构一般有两种类型，它们分别是顺序存储结构、链式存储结构<br>\n 6. 在一般情况下，一个算法的时间复杂度是问题规模的函数<br>\n 7. 常见时间复杂度有：常数阶 O（1）、线性阶 O（n）、对数阶 O（log 2 n）、平方阶 O (n^2)、<br>\n指数阶 O (2^n)。通常认为，具有常数阶量级的算法是好算法，而具有指数阶量级的算法是<br>\n差算法。</p>\n<h1 id=\"第二章-线性表\"><a class=\"markdownIt-Anchor\" href=\"#第二章-线性表\">#</a> 第二章 线性表</h1>\n<p>定义： 线性表是 n 个数据元素的有限序列。 一个数据元素可由若干个 数据项组成。</p>\n<p>顺序表结构<br>\n线性表的顺序存储是指在内存中 用地址连续的一块存储空间顺序存放线性表的各元素，用这<br>\n种存储形式存储的线性表称为顺序表。<br>\n单链表<br>\n（1） 链表结点结构<br>\n线性表中的数据元素可以 用任意的一组存储单元来存储，用指针表示逻辑关系逻辑相邻的两<br>\n元素的存储空间可以是不连续的。<br>\n（2） 链表操作算法：初始化、插入、输出、删除、遍历<br>\n<strong>初始化：p=(struct student <em>)malloc(sizeof(struct student));<br>\n 插入： p-&gt;next=head-&gt;next; head-&gt;next=p;<br>\n 输出：printf (“% d”,p-&gt;data);<br>\n 删除：q=p-&gt;next; p-&gt;next = q-&gt;next ; free (q);<br>\n 结点遍历： for (p=head;p;p=p-&gt;next);</em></strong><br>\n 补充内容：<br>\n1、线性表中，第一个元素没有直接前驱，最后一个元素没有直接后驱。<br>\n2、在一个单链表中，若 p 所指结点是 q 所指结点的前驱结点，则删除结点 q 的操作语句为<br>\n P-&gt;next = q-&gt;next ; free (q);<br>\n3、在长度为 N 的顺序表中，插入一个新元素平均需要移动表中 N/2 个元素，删除一个元素<br>\n平均需要移动（N-1）/2 个元素。<br>\n4、若线性表的主要操作是在最后一个元素之后插入一个元素或删除最后一个元素，则采用<br>\n顺序表存储结构最节省运算时间。<br>\n5、已知顺序表中每个元素占用 3 个存储单元，第 13 个元素的存储地址为 336，则顺序表的<br>\n首地址为 300。（第 n 个元素的地址即首地址 +(n-1) 每个元素的存储空间，如 a [12]（第 13<br>\n 个元素）的地址 = a [0]+123）<br>\n6、设有一带头结点单链表 L，请编写该单链表的初始化，插入、输出和删除函数。（函数名<br>\n自定义）<br>\n结点定义：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">int</span> datatype; <span class=\"comment\">//结点数据类型，假设为 int</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span> &#123;</span> <span class=\"comment\">//结点结构</span></span><br><span class=\"line\">datatype data;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span> *<span class=\"title\">next</span>;</span> <span class=\"comment\">//双向链表还应加上*previous</span></span><br><span class=\"line\">&#125; Lnode, * pointer ; <span class=\"comment\">//结点类型,结点指针类型</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> pointer lklist; <span class=\"comment\">//单链表类型，即头指针类型</span></span><br><span class=\"line\"><span class=\"comment\">//1.初始化：</span></span><br><span class=\"line\">lklist <span class=\"title function_\">initlist</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">pointer head;</span><br><span class=\"line\">head=new node;<span class=\"comment\">//这是 C++做法</span></span><br><span class=\"line\"><span class=\"comment\">//head=( pointer)malloc(sizeof(Lnode)); 这是 C 语言做法</span></span><br><span class=\"line\">head-&gt;next=<span class=\"literal\">NULL</span>; <span class=\"comment\">//循环链表则是 head-&gt;next=head;</span></span><br><span class=\"line\"><span class=\"comment\">//双向链表应加上 head-&gt;previos=NULL;</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> head;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//2.插入：（C 语言中需要把 head 转化为全局变量才能实现此程序）</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">insert</span><span class=\"params\">(lklist head,datatype x,<span class=\"type\">int</span> i)</span>&#123;</span><br><span class=\"line\">pointer q,s;</span><br><span class=\"line\">q=get(head,i<span class=\"number\">-1</span>); <span class=\"comment\">//找第 i-1 个点</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(q==<span class=\"literal\">NULL</span>) <span class=\"comment\">//无第 i-1 点，即 i&lt;1 或 i&gt;n+1 时</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"built_in\">cout</span>&lt;&lt;”非法插入位置!\\n”; <span class=\"comment\">//这是 C++做法，即 C 语言中的 printf(“非法插入位置!\\n”);</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">s=new node;<span class=\"comment\">//生成新结点 即 C 语言中的 s=( pointer)malloc(sizeof(Lnode));</span></span><br><span class=\"line\">s-&gt;data=x;</span><br><span class=\"line\">s-&gt;next=q-&gt;next; <span class=\"comment\">//新点的后继是原第 i 个点</span></span><br><span class=\"line\">q-&gt;next=s; <span class=\"comment\">//原第 i-1 个点的后继是新点</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">1</span>; <span class=\"comment\">//插入成功</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//3.删除：（C 语言中需要把 head 转化为全局变量才能实现此程序）</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">delete</span><span class=\"params\">(lklist head,<span class=\"type\">int</span> i)</span> &#123;</span><br><span class=\"line\">pointer p,q;</span><br><span class=\"line\">q=get(head,i<span class=\"number\">-1</span>); <span class=\"comment\">//找待删点的直接前趋</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(q==<span class=\"literal\">NULL</span> || q-&gt;next==<span class=\"literal\">NULL</span>) <span class=\"comment\">//即 i&lt;1 或 i&gt;n 时</span></span><br><span class=\"line\">&#123;<span class=\"built_in\">cout</span>&lt;&lt;”非法删除位置!\\n”;<span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br><span class=\"line\">p=q-&gt;next; <span class=\"comment\">//保存待删点地址</span></span><br><span class=\"line\">q-&gt;next=p-&gt;next; <span class=\"comment\">//修改前趋的后继指针</span></span><br><span class=\"line\">delete p; <span class=\"comment\">//释放结点 即 C 语言中的 free(p);</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">1</span>; <span class=\"comment\">//删除成功</span></span><br></pre></td></tr></table></figure>\n<p>不带头结点的单链表 head 为空的判定条件是 (A)<br>\nA. head=NULL B. head-&gt;next=NULL C. head-&gt;next=head D. head!=NULL<br>\n 带头结点的单链表 head 为空的判定条件是 (B)<br>\nA. head=NULL B. head-&gt;next=NULL C. head-&gt;next=head D. head!=NULL<br>\n 在一个单链表中，若 p 所指结点不是最后结点，在 p 之后插入 s 所指结点，则执行 (B)<br>\nA. s-&gt;next=p; p-&gt;next=s; B. s-&gt;next=p-&gt;next; p-&gt;next=s;<br>\nC. s-&gt;next=p-&gt;next; p=s; D. p-&gt;next=s; s-&gt;next=p;<br>\n 在一个单链表中，若删除 p 所指结点的后续结点，则执行 (A)<br>\nA. p-&gt;next=p-&gt;next-&gt;next;<br>\nB. p=p-&gt;next; p-&gt;next=p-&gt;next-&gt;next;<br>\nC. p-&gt;next=p-&gt;next<br>\nD. p=p-&gt;next-&gt;next<br>\n 从一个具有 n 个结点的有序单链表中查找其值等于 x 结点时，在查找成功的情况下，需平均比较（B ）个结点。<br>\nA. n B. (n+1)/2 C. (n-1)/2 D. O(n ㏒ 2n)<br>\n 给定有 n 个元素的向量，建立一个有序单链表的时间复杂度（B）<br>\nA.O(1) B.O(n) C.O(n2) D.O(n ㏒ 2n)<br>\n 在一个具有 n 个结点的有序单链表中插入一个新结点并仍然有序的时间复杂度是 (B)<br>\nA.O(1) B.O(n) C.O(n2) D.O(n ㏒ 2n)<br>\n 在一个单链表中删除 q 所指结点时，应执行如下操作：<br>\nq=p-&gt;next;<br>\np-&gt;next=( p-&gt;next-&gt;next );<br>\nfree (q);// 这种题目靠一根指针是没有办法完成的，必须要借助第二根指针。<br>\n在一个单链表中 p 所指结点之后插入一个 s 所指结点时，应执行：<br>\ns-&gt;next=( p-&gt;next )<br>\n p-&gt;next=(s) 操作。<br>\n对于一个具有 n 个节点的单链表，在已知所指结点后插入一个新结点的时间复杂度是 (O<br>\n（1）)；在给定值为 x 的结点后插入一个新结点的时间复杂度是（O (n)）。<br>\n11. 问答题<br>\n线性表可用顺序表或链表存储。试问：<br>\n(1) 两种存储表示各有哪些主要优缺点？<br>\n 顺序表的存储效率高，存取速度快。但它的空间大小一经定义，在程序整个运行期间不会发<br>\n生改变，因此，不易扩充。同时，由于在插入或删除时，为保持原有次序，平均需要移动一<br>\n半 (或近一半) 元素，修改效率不高。<br>\n链接存储表示的存储空间一般在程序的运行过程中动态分配和释放，且只要存储器中还有空<br>\n间，就不会产生存储溢出的问题。同时在插入和删除时不需要保持数据元素原来的物理顺序，<br>\n只需要保持原来的逻辑顺序，因此不必移动数据，只需修改它们的链接指针，修改效率较高。<br>\n但存取表中的数据元素时，只能循链顺序访问，因此存取效率不高。<br>\n(2) 若表的总数基本稳定，且很少进行插入和删除，但要求以最快的速度存取表中的元素，<br>\n这时，应采用哪种存储表示？为什么？<br>\n应采用顺序存储表示。因为顺序存储表示的存取速度快，但修改效率低。若表的总数基本稳<br>\n定，且很少进行插入和删除，但要求以最快的速度存取表中的元素，这时采用顺序存储表示<br>\n较好。</p>\n<h1 id=\"第三章-栈和队列\"><a class=\"markdownIt-Anchor\" href=\"#第三章-栈和队列\">#</a> 第三章 栈和队列</h1>\n<ol>\n<li>栈<br>\n（1） 栈的结构与定义<br>\n定义：限定仅在表尾进行插入或删除操作的线性表。<br>\n结构：<br>\ntypedef struct list{<br>\nint listsize; // 栈的容量<br>\n struct list *head; // 栈顶指针<br>\n struct list *base; // 栈底指针<br>\n}</li>\n</ol>\n<p>（2） 顺序栈操作算法：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 初始化栈</span></span><br><span class=\"line\">Status <span class=\"title function_\">InitStack</span><span class=\"params\">(SqStack *S)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 分配初始空间</span></span><br><span class=\"line\">    S-&gt;base = (ElemType *) <span class=\"built_in\">malloc</span>(Stack_Init_Size * <span class=\"keyword\">sizeof</span>(ElemType));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!S-&gt;base) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    S-&gt;top = S-&gt;base; <span class=\"comment\">/// 栈顶与栈底相同</span></span><br><span class=\"line\">    S-&gt;stack_size = Stack_Init_Size; <span class=\"comment\">// 栈的最大长度等于初始长度</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 判断栈是否为空，只需要判断栈顶指针与栈底指针是否相同即可</span></span><br><span class=\"line\">Status <span class=\"title function_\">EmptyStack</span><span class=\"params\">(SqStack *S)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> S-&gt;base == S-&gt;top;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取栈的实际长度，栈顶减去栈底指针即为栈的长度</span></span><br><span class=\"line\">Status <span class=\"title function_\">LengthStack</span><span class=\"params\">(SqStack *S)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (S-&gt;top == S-&gt;base) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (Status) (S-&gt;top - S-&gt;base);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取栈顶的元素，参数e用来存放栈顶的元素</span></span><br><span class=\"line\">Status <span class=\"title function_\">GetTopStack</span><span class=\"params\">(SqStack *S, ElemType *e)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (S-&gt;top == S-&gt;base) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    *e = *(S-&gt;top - <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 进栈，参数e是要进栈的元素</span></span><br><span class=\"line\">Status <span class=\"title function_\">PushStack</span><span class=\"params\">(SqStack *S, ElemType e)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 若栈的最大长度不会够用时，重新开辟，增大长度</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (S-&gt;top - S-&gt;base &gt;= S-&gt;stack_size) &#123;</span><br><span class=\"line\">        S-&gt;base = (ElemType *)<span class=\"built_in\">realloc</span>(S-&gt;base, (S-&gt;stack_size + StackIncrement) * <span class=\"keyword\">sizeof</span>(ElemType));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!S-&gt;base) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 栈顶指针为栈底指针加上栈之前的最大长度</span></span><br><span class=\"line\">        S-&gt;top = S-&gt;base + S-&gt;stack_size;</span><br><span class=\"line\">        <span class=\"comment\">// 栈当前的最大长度等于栈之前的最大长度与增加的长度之和</span></span><br><span class=\"line\">        S-&gt;stack_size += StackIncrement;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    *S-&gt;top++ = e; <span class=\"comment\">// 先赋值，后栈顶指针上移</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 出栈，参数e用来存放出栈的元素</span></span><br><span class=\"line\">Status <span class=\"title function_\">PopStack</span><span class=\"params\">(SqStack *S, ElemType *e)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (S-&gt;base == S-&gt;top) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    *e = *--S-&gt;top; <span class=\"comment\">// 栈顶指针先下移，后赋值</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 销毁栈，释放栈空间，栈顶栈底指针置为NULL，长度置为0</span></span><br><span class=\"line\">Status <span class=\"title function_\">DestroyStack</span><span class=\"params\">(SqStack *S)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(S-&gt;base);</span><br><span class=\"line\">    S-&gt;base = S-&gt;top = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    S-&gt;stack_size = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 遍历栈，依次打印每个元素</span></span><br><span class=\"line\">Status <span class=\"title function_\">StackTraverse</span><span class=\"params\">(SqStack *S)</span> &#123;</span><br><span class=\"line\">    ElemType *p;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (S-&gt;top == S-&gt;base) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Stack is NULL.\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    p = S-&gt;top;</span><br><span class=\"line\">    <span class=\"comment\">// 由栈顶依次向下遍历</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (p &gt; S-&gt;base) &#123;</span><br><span class=\"line\">        p--;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>, *p);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>（3） 链栈操作算法<br>\n结构：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">StackNode</span>&#123;</span></span><br><span class=\"line\">\t ElemType data;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">StackNode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125;StackNode, *LinkStack;</span><br></pre></td></tr></table></figure>\n<p>初始化：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Status <span class=\"title function_\">InitStack</span><span class=\"params\">(LinkStack &amp;S)</span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//构造一个空栈，栈顶指针置为空 </span></span><br><span class=\"line\">\tS = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>入栈：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Status <span class=\"title function_\">Push</span><span class=\"params\">(LinkStack &amp;S,ElemType e)</span>&#123;</span><br><span class=\"line\">\t    LinkStack p;<span class=\"comment\">//定义p </span></span><br><span class=\"line\">\t\tp=new StackNode;<span class=\"comment\">//生成新结点 </span></span><br><span class=\"line\">\t\tp-&gt;data=e;<span class=\"comment\">//e赋给新结点的数据域 </span></span><br><span class=\"line\">\t\tp-&gt;next=S; <span class=\"comment\">//新结点插入栈顶 </span></span><br><span class=\"line\">\t\tS=p;<span class=\"comment\">//修改栈顶指针为p</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>出栈：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Status <span class=\"title function_\">Pop</span><span class=\"params\">(LinkStack &amp;S,ElemType &amp;e)</span>&#123;</span><br><span class=\"line\">\tLinkStack p;<span class=\"comment\">//定义p </span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(S==<span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> ERROR;<span class=\"comment\">//栈空 </span></span><br><span class=\"line\">\te=S-&gt;data;<span class=\"comment\">//将栈顶元素赋给e </span></span><br><span class=\"line\">\tp=S;<span class=\"comment\">//p临时保存栈顶元素以备释放 </span></span><br><span class=\"line\">\tS=S-&gt;next;<span class=\"comment\">//修改栈顶指针 </span></span><br><span class=\"line\">\tdelete p;<span class=\"comment\">//释放空间 </span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>队列<br>\n（1） 队列的定义<br>\n定义：只允许在表的一端进行插入，而在另一端删除元素。</li>\n</ol>\n<p>补充内容：<br>\n1、一个栈的入栈序列为 “ABCDE”，则以下不可能的出栈序列是（B）<br>\nA. BCDAE B. EDACB C. BCADE D. AEDCB<br>\n2、栈的顺序表示中，用 TOP 表示栈顶元素，那么栈空的条件是（D）<br>\nA. TOPSTACKSIZE B. TOP1 C. TOP0 D. TOP-1<br>\n3、允许在一端插入，在另一端删除的线性表称为队列。插入的一端为表头，删除的一端为<br>\n表尾。<br>\n4、栈的特点是先进后出，队列的特点是先进先出。<br>\n5、对于栈和队列，无论他们采用顺序存储结构还是链式存储结构，进行插入和删除操作的<br>\n时间复杂度都是 O (1)（即与已有元素 N 无关）。<br>\n6、已知链栈 Q，编写函数判断栈空，如果栈空则进行入栈操作，否则出栈并输出。（要求判<br>\n断栈空、出栈、入栈用函数实现）（详看考点 2）<br>\n7. 出队与取队头元素的区别：出队就是删除对头的数据元素，取队头元素是获取对头的数据<br>\n元素值，不需要删除。<br>\n8. 链栈与顺序栈相比，比较明显的优点是：（D）<br>\nA. 插入操作比较容易 B. 删除操作比较容易<br>\n C. 不会出现栈空的情况 D. 不会出现栈满的情况</p>\n<p>考点 1：队列的编程：<br>\n结构：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">QNode</span>&#123;</span></span><br><span class=\"line\"><span class=\"type\">int</span> date;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">QNode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125;QNode,*QueuePtr;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">QueuePtr front;</span><br><span class=\"line\">QueuePtr rear;</span><br><span class=\"line\">&#125;LinkQueue;</span><br></pre></td></tr></table></figure>\n<p>创建：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LinkQueue <span class=\"title function_\">InitQueue</span><span class=\"params\">(LinkQueue Q)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">Q.front=Q.rear=(QueuePtr)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(QNode));</span><br><span class=\"line\">Q.front-&gt;next=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\"><span class=\"keyword\">return</span> (Q);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>入队：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LinkQueue <span class=\"title function_\">EnQueue</span><span class=\"params\">(LinkQueue Q,<span class=\"type\">int</span> e)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">QueuePtr p;</span><br><span class=\"line\">p=(QueuePtr)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(QNode));</span><br><span class=\"line\">p-&gt;date=e;</span><br><span class=\"line\">p-&gt;next=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">Q.rear-&gt;next=p;</span><br><span class=\"line\">Q.rear=p;</span><br><span class=\"line\"><span class=\"keyword\">return</span> (Q);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>出队：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LinkQueue <span class=\"title function_\">DeQueue</span><span class=\"params\">(LinkQueue Q)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"type\">int</span> e;</span><br><span class=\"line\">QueuePtr p;</span><br><span class=\"line\">p=Q.front-&gt;next;</span><br><span class=\"line\">e=p-&gt;date;</span><br><span class=\"line\">Q.front=p-&gt;next;</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>,e);</span><br><span class=\"line\"><span class=\"keyword\">if</span>(Q.rear==p)Q.rear=Q.front=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\"><span class=\"built_in\">free</span>(p);</span><br><span class=\"line\"><span class=\"keyword\">return</span> (Q);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"第四章-串\"><a class=\"markdownIt-Anchor\" href=\"#第四章-串\">#</a> 第四章 串</h1>\n<p>1. 串是由零个或多个字符组成的有限序列<br>\n 2. 串的赋值：x=’abc’; 或 x [ ]=’abc’;</p>\n<p>第五章 数组和广义表 （不是重点内容）<br>\n多维数组中某数组元素的 position 求解。一般是给出数组元素的首元素地址和每个元素占<br>\n用的地址空间并组给出多维数组的维数，然后要求你求出该数组中的某个元素所在的位置。<br>\n明确 按行存储和 按列存储的区别和联系，并能够按照这两种不同的存储方式求解 1 中类<br>\n型的题。<br>\n将特殊矩阵中的元素按相应的换算方式存入数组中。这些矩阵包括：对称矩阵，三角矩<br>\n阵，具有某种特点的稀疏矩阵等。熟悉稀疏矩阵的三种不同存储方式： 三元组，带辅助行向<br>\n量的二元组， 十字链表存储。掌握将稀疏矩阵的三元组或二元组向十字链表进行转换的算法。<br>\n补充内容：<br>\n三元组：<br>\n结构：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\"><span class=\"type\">int</span> i,j; <span class=\"comment\">//元素行下标及列下标</span></span><br><span class=\"line\"><span class=\"type\">int</span> e; <span class=\"comment\">//元素值</span></span><br><span class=\"line\">&#125;Triple;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\"><span class=\"type\">int</span> mu,nu,tu; <span class=\"comment\">//矩阵的行数、列数、非零元素个数</span></span><br><span class=\"line\">Triple data[MAXSIZE+<span class=\"number\">1</span>]; <span class=\"comment\">//矩阵包含的三元组表，data[0]未用</span></span><br><span class=\"line\">&#125;TSMatrix;</span><br></pre></td></tr></table></figure>\n<p>十字链表：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">OLNode</span>&#123;</span></span><br><span class=\"line\"><span class=\"type\">int</span> i,j; <span class=\"comment\">//元素行下标及列下标</span></span><br><span class=\"line\"><span class=\"type\">int</span> e; <span class=\"comment\">//元素值</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">OLNode</span> *<span class=\"title\">right</span>,*<span class=\"title\">down</span>;</span> <span class=\"comment\">//行的后继以及列的后继</span></span><br><span class=\"line\">&#125; OLNode，*OLink;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\"><span class=\"type\">int</span> mu,nu,tu; <span class=\"comment\">//矩阵的行数、列数、非零元素个数</span></span><br><span class=\"line\">OLink *rhead,*chead; <span class=\"comment\">//行和列的表头指针组的首地址</span></span><br><span class=\"line\">&#125;CrossList;</span><br><span class=\"line\"></span><br><span class=\"line\">CrossList Creat（CrossList M）&#123;</span><br><span class=\"line\"><span class=\"type\">int</span> m,n,t;</span><br><span class=\"line\"><span class=\"built_in\">scanf</span>(“%d%d%d”,&amp;m,&amp;n,&amp;t);</span><br><span class=\"line\">M.mu=m;M.nu=n;M.tu=t;</span><br><span class=\"line\">M.rhead=( OLink *)<span class=\"built_in\">malloc</span>((m+<span class=\"number\">1</span>)*<span class=\"keyword\">sizeof</span>(OLink)); <span class=\"comment\">//开辟行表头指针组</span></span><br><span class=\"line\">M.chead=( OLink *)<span class=\"built_in\">malloc</span>((n+<span class=\"number\">1</span>)*<span class=\"keyword\">sizeof</span>(OLink)); <span class=\"comment\">//开辟行列头指针组</span></span><br><span class=\"line\">M.rhead[]=M.chead[]=<span class=\"literal\">NULL</span>; <span class=\"comment\">//初始化</span></span><br><span class=\"line\">…… <span class=\"comment\">//接下来就是赋值和入链</span></span><br><span class=\"line\">｝</span><br></pre></td></tr></table></figure>\n<h1 id=\"第六章-树和二叉树\"><a class=\"markdownIt-Anchor\" href=\"#第六章-树和二叉树\">#</a> 第六章 树和二叉树</h1>\n<h2 id=\"1-树\"><a class=\"markdownIt-Anchor\" href=\"#1-树\">#</a> 1． 树</h2>\n<p>（1） 树的概念及术语<br>\n树 ：n（n≥0）个结点的有限集合。当 n＝0 时，称为空树；任意一棵非空树满足以下条件：<br>\n⑴ 有且仅有一个特定的称为根的结点；<br>\n⑵ 当 n＞1 时，除根结点之外的其余结点被分成 m（m&gt;0）个互不相交的有限集合<br>\n T1,T2,… ,Tm，其中每个集合又是一棵树，并称为这个根结点的子树。<br>\n（2） 结点的度： 结点所拥有的子树的个数。<br>\n树的度：树中所有结点的度的最大值。<br>\n（3） 叶子结点： 度为 0 的结点，也称为终端结点。<br>\n分支结点：度不为 0 的结点，也称为非终端结点。<br>\n（4）孩子、双亲 ：树中某结点的子树的根结点称为这个结点的孩子结点，这个结点称为它<br>\n孩子结点的双亲结点；<br>\n兄弟： 具有同一个双亲的孩子结点互称为兄弟。<br>\n（5）路径： 如果树的结点序列 n1, n2, …, nk 有如下关系：结点 ni 是 ni+1 的双亲（1&lt;=i&lt;k），<br>\n则把 n1, n2, …, nk 称为一条由 n1 至 nk 的路径；路径上经过的边的个数称为路径长度。<br>\n（6）祖先、子孙： 在树中，如果有一条路径从结点 x 到结点 y，那么 x 就称为 y 的祖先，<br>\n而 y 称为 x 的子孙。<br>\n（7）结点所在层数： 根结点的层数为 1；对其余任何结点，若某结点在第 k 层，则其孩子<br>\n结点在第 k+1 层。<br>\n树的深度： 树中所有结点的最大层数，也称高度。<br>\n（8）层序编号： 将树中结点按照从上层到下层、同层从左到右的次序依次给他们编以从 1<br>\n 开始的连续自然数。<br>\n（9）有序树、无序树： 如果一棵树中结点的各子树从左到右是有次序的，称这棵树为有序<br>\n树；反之，称为无序树。数据结构中讨论的一般都是有序树<br>\n（10） 树通常有前序（根）遍历、后序（根）遍历和层序（次）遍历三种方式（树，<br>\n不是二叉树，没中序遍历。)</p>\n<h2 id=\"2-二叉树\"><a class=\"markdownIt-Anchor\" href=\"#2-二叉树\">#</a> 2． 二叉树</h2>\n<p>（1）二叉树的定义：二叉树是 n（n≥0）个结点的有限集合，该集合或者为空集（称为空<br>\n二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉<br>\n树组成。</p>\n<p>满二叉树：在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在<br>\n同一层上。<br>\n（满二叉树的特点：叶子只能出现在最下一层；只有度为 0 和度为 2 的结点。）<br>\n完全二叉树：对一棵具有 n 个结点的二叉树按层序编号，如果编号为 i（1≤i≤n）的结点与<br>\n同样深度的满二叉树中编号为 i 的结点在二叉树中的位置完全相同。<br>\n完全二叉树的特点：<br>\n1. 在满二叉树中，从最后一个结点开始，连续去掉任意个结点，即是一棵完全二叉树。<br>\n2. 叶子结点只能出现在最下两层，且最下层的叶子结点都集中在二叉树的左部；</p>\n<p>3. 完全二叉树中如果有度为 1 的结点，只可能有一个，且该结点只有左孩子。</p>\n<p>4. 深度为 k 的完全二叉树在 k-1 层上一定是满二叉树。</p>\n<p>（2）二叉树的性质：<br>\n性质 1：二叉树的第 i 层上最多有 2i-1 个结点（i≥1）。<br>\n性质 2： 一棵深度为 k 的二叉树中，最多有 2k-1 个结点，最少有 k 个结点。深度为 k<br>\n 且具有 2k-1 个结点的二叉树一定是满二叉树<br>\n性质 3：在一棵二叉树中，如果叶子结点数为 n0，度为 2 的结点数为 n2，则有: n0＝n2<br>\n＋1。（一个结点的度就是指它放出的射线）<br>\n性质 4：具有 n 个结点的完全二叉树的深度为 log2n +1。<br>\n性质 5： 对一棵具有 n 个结点的完全二叉树中从 1 开始按层序编号，则对于任意的序<br>\n号为 i（1≤i≤n）的结点（简称为结点 i），有：<br>\n（1）如果 i＞1，则结点 i 的双亲结点的序号为 i/2；如果 i＝1，则结点 i 是根结点，无双<br>\n亲结点。<br>\n（2）如果 2i≤n，则结点 i 的左孩子的序号为 2i；如果 2i＞n，则结点 i 无左孩子。<br>\n（3）如果 2i＋1≤n，则结点 i 的右孩子的序号为 2i＋1；如果 2i＋1＞n，则结点 i 无右孩子。</p>\n<h2 id=\"3-二叉树的遍历递归调用与访问的顺序不同而产生不同的遍历方法\"><a class=\"markdownIt-Anchor\" href=\"#3-二叉树的遍历递归调用与访问的顺序不同而产生不同的遍历方法\">#</a> 3． 二叉树的遍历（递归调用与访问的顺序不同而产生不同的遍历方法）</h2>\n<p>（1） 先序遍历</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">XianXu</span><span class=\"params\">(BiTree T)</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(T)&#123;</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%c&quot;</span>,T-&gt;data); <span class=\"comment\">//先访问</span></span><br><span class=\"line\">XianXu(T-&gt;lchild); <span class=\"comment\">//再继续遍历</span></span><br><span class=\"line\">XianXu(T-&gt;rchild);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>（2） 中序遍历<br>\n（3） 后序遍历</p>\n<h2 id=\"4-森林与二叉树的转换\"><a class=\"markdownIt-Anchor\" href=\"#4-森林与二叉树的转换\">#</a> 4. 森林与二叉树的转换</h2>\n<p>（1）同级以左为亲，即左一结点的右孩子是与它同级的右一结点<br>\n（2）只认最左路线为亲子路线，即结点的左孩子是它下一级结点的最左的元素</p>\n<h2 id=\"5-哈夫曼树\"><a class=\"markdownIt-Anchor\" href=\"#5-哈夫曼树\">#</a> 5. 哈夫曼树</h2>\n<p>(1）哈夫曼树的基本概念：<br>\n哈夫曼树：给定一组具有确定权值的叶子结点， 带权路径长度最小的二叉树。<br>\n(2）哈夫曼树的特点：</p>\n<p>权值越大的叶子结点越靠近根结点，而权值越小的叶子结点越远离根结点。<br>\n只有度为 0（叶子结点）和度为 2（分支结点）的结点，不存在度为 1 的结点.<br>\n（3）哈夫曼树的构造算法思想及构造过程（森林与 哈夫曼编码）<br>\n就是求各权值和路径相乘之后叠加的最小值。</p>\n<p>1、已知一棵完全二叉树有 47 个结点，则该二叉树有（C）个叶子结点。<br>\nA. 6 B. 12 C. 24 D.48<br>\n 解法如下：<br>\n1+2+4+8+16=31 计算从第一层到 n-1 层的结点个数<br>\n 47-31=16 计算第 n 层的叶子结点个数<br>\n 16-16/2=8 计算第 n-1 层的叶子结点个数<br>\n所以，叶子结点数 = 16+8=24 计算第 n 层和第 n-1 层的总叶子结点数<br>\n 2、已知遍历一棵二叉树的前序序列 ABCDEFG 和中序序列 CBEDAFG，那么是下面哪棵树<br>\n（C ）。<br>\nC 图如下：<br>\n　　　　　　　　　　　 A<br>\n　　　　　　　　　　↙　 ↘<br>\n　　　　　　　　　 Ｂ　　　F<br>\n　　　　　　　　↙ 　↘ 　　　↘<br>\n　　　　　　　C 　　　D 　　　　 G<br>\n　　　　　　　　　　↙<br>\n　　　　　　　　　E<br>\n4、完全二叉树必须满足的条件为: ：一棵具有 n 个结点的二叉树，它的结构与满二叉树的<br>\n前 n 个结点的的结构相同。<br>\n5、哈夫曼树不存在度为 1 的结点。<br>\n6、有 5 个带权结点，其权值分别为 2，5，3，7，11，根据哈夫曼算法构建该树，并计算该<br>\n树的带权路径长度。（构建哈夫曼树，很简单，从小开始，计算相加，然后把所有叶子结点<br>\n乘以等级数字然后相加。也即是：带权路径长度 = 叶结点的权值 * 路径长度）<br>\n7. 试找出分别满足下列条件的所有二叉树：<br>\n⑴ 前序序列和中序序列相同：只有右子树<br>\n⑵ 中序序列和后序序列相同：只有左子树<br>\n⑶ 前序序列和后序序列相同：只有根，空二叉树</p>\n<h1 id=\"第七章-图\"><a class=\"markdownIt-Anchor\" href=\"#第七章-图\">#</a> 第七章 图</h1>\n<ol>\n<li>\n<p>图的基本概念：<br>\n图的结点之间的关系可以是任意的，图中任意两个数据元素之间都可能相关。<br>\n设图有 n 个顶点，则：<br>\n有 1/2 n (n-1) 条边的无向图称为 完全图<br>\n有 n（n-1）条弧的有向图称为 有向完全图<br>\n元素被多少条弧的箭头所指，它的 入度就为多少；反之，出度。<br>\n第一个顶点和最后一个顶点相同的路径叫做 回路或环 环<br>\n顶点不重复出现的路径叫 简单路径<br>\n若图中任意两个顶点之间存在路径（不一定是直接相连），则称作 连通图。</p>\n</li>\n<li>\n<p>邻接矩阵：<br>\n．<br>\n　　　　　　　　　　　　　　W i,j &lt;V i ，V j &gt; ∈VR<br>\n　　邻接矩阵的定义： A [i][j]={<br>\n　　　　　　　　　　　　　　0 即 VR 中不存在 &lt;V i ，V j&gt; 时</p>\n</li>\n<li>\n<p>图的遍历<br>\n（1）深度优先遍历<br>\n步骤：1. 从任意顶点开始访问。<br>\n2. 访问后把该元素对应的访问标志赋值为 1 表示已访问该数据元素<br>\n 3. 寻找与其有关未被访问的所有邻接顶点，并从该顶点开始进行访问</p>\n</li>\n<li>\n<p>重复 2、3 步骤直到该连通图的所有顶点均已访问完毕<br>\n（2）广度优先遍历<br>\n步骤：1. 从任意顶点开始访问。<br>\n2. 访问后把该元素对应的访问标志赋值为 1 表示已访问该数据元素<br>\n 3. 寻找与其有关未被访问的邻接顶点，并按顺序入列直到所有邻接顶点均<br>\n已访问完毕<br>\n 4. 把最先入列的顶点出列，以它为顶点开始访问</p>\n</li>\n<li>\n<p>重复 2、3、4 步骤直到该连通图的所有顶点均已访问完毕</p>\n</li>\n</ol>\n<h1 id=\"第八九十章\"><a class=\"markdownIt-Anchor\" href=\"#第八九十章\">#</a> 第八九十章</h1>\n<p>查找表<br>\n是由同一类型的数据元素（或记录）构成的集合<br>\n对查找表的操作有：<br>\n（1） 查询某个 “特定的” 数据元素是否在查找表中；<br>\n（2） 检索某个 “特定的” 数据元素的各种属性<br>\n（3） 在查找表中插入一个数据元素；<br>\n（4） 从查找表中删去某个特定元素<br>\n静态查找表<br>\n只进行前两种 “查找” 操作的查找表为静态查找表<br>\n动态查找表<br>\n若在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已存在的某<br>\n个数据元素，则成为动态查找表<br>\n排序<br>\n其功能是将一个数据元素（或记录）的任意序列，重新排列成一个按关键字有序的序列。</p>\n",
            "tags": [
                "期末复习"
            ]
        },
        {
            "id": "http://example.com/2023/05/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%A0%E9%A2%98%E5%A4%8D%E4%B9%A0/",
            "url": "http://example.com/2023/05/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%A0%E9%A2%98%E5%A4%8D%E4%B9%A0/",
            "title": "操作系统习题汇总",
            "date_published": "2023-05-24T04:59:44.000Z",
            "content_html": "<h1 id=\"第一章-操作系统概述\"><a class=\"markdownIt-Anchor\" href=\"#第一章-操作系统概述\">#</a> 第一章 操作系统概述</h1>\n<p>1）一个完整的计算机系统是由硬件系统和软件系统两大部分组成</p>\n<p>2）计算机软件是指程序和与程序相关的文档的集合</p>\n<p>3）按功能可把软件分为 “系统软件” 和 “应用软件” 两部分</p>\n<p>系统软件：操作系统语言处理程序，数据库管理系统</p>\n<p>应用软件：各种管理软件，用于工程计算的软件包，辅助设计软件</p>\n<p>4）通常把未配置任何软件的计算机称为 “裸机”</p>\n<p>5）操作系统可以被看作是计算机系统的核心，统管整个系统资源，制定各种资源的分配策略，调度系统中运行的用户程序，协调它们对资源的需求，从而使整个系统在高效、有序的环境里工作。</p>\n<p>6）发展的动力：</p>\n<p>(1) 提高计算机资源的利用率的需要</p>\n<p>(2) 方便用户使用计算机的需要</p>\n<p>(3) 硬件技术不断发展的需要</p>\n<p>(4) 计算机体系结构发展的需要</p>\n<p>7）操作系统是在 “裸机” 上加载的第一层软件，是对计算机硬件系统功能的首次扩充</p>\n<p>8）操作系统的定义：</p>\n<p>操作系统是控制和管理计算机硬件和软件资源，合理地组织计算机工作流程，以及方便用户使用计算机的一个大型程序</p>\n<p>9）操作系统的功能：</p>\n<p>Ø 处理机管理：进程控制，进程同步，进程通信、调度、实施 CPU 分配</p>\n<p>Ø 存储器管理：内存分配，内存保护，地址映射，内存扩充</p>\n<p>Ø 设备管理：缓冲管理，设备分配，设备管理</p>\n<p>Ø 文件管理：存储空间管理，目录管理，读写管理和保护</p>\n<p>Ø 与用户有关的接口：用户接口，程序接口，人机交互</p>\n<p>10）操作系统另一种定义：操作系统是一组能有效地组织和管理计算机硬件和软件资源，合理地对各类作业进行调度，以及方便用户使用的程序的集合</p>\n<h2 id=\"操作系统的种类\"><a class=\"markdownIt-Anchor\" href=\"#操作系统的种类\">#</a> 操作系统的种类：</h2>\n<ol>\n<li>单道批处理系统</li>\n</ol>\n<p>特点：单路性、独占性、自动性、封闭性、顺序性</p>\n<p>缺点：系统的资源得不到充分的利用</p>\n<ol start=\"2\">\n<li>多道批处理系统</li>\n</ol>\n<p>特点：多路性、共享性、自动型、封闭性、无序性、调度性</p>\n<p>好处：</p>\n<p>ü 提高 CPU 的利用率</p>\n<p>ü 提高内存和 I/O 设备的利用率</p>\n<p>ü 增加系统吞吐量</p>\n<p>缺点：平均周转时间长，无交互能力</p>\n<ol start=\"3\">\n<li>分时系统</li>\n</ol>\n<p>分时系统是指在一台主机上连接了多个配有显示器和键盘的终端，由此所组成的系统，该系统允许多个用户同时通过自己的终端，以交互方式使用计算机，共享主机中的资源。</p>\n<p>采用了 “时间片轮转” 的处理机调度策略</p>\n<ol start=\"4\">\n<li>实时系统</li>\n</ol>\n<p>实时系统是指系统能及时响应外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有实时任务协调一致地运行</p>\n<h1 id=\"第二章-处理机管理\"><a class=\"markdownIt-Anchor\" href=\"#第二章-处理机管理\">#</a> 第二章 处理机管理</h1>\n<p><strong>1. 进程是指在系统中能独立运行并作为资源分配的基本单位，它是由一组机器指令，数据和堆栈等组成的，是一个能独立运行的活动实体，多个进程可以并发执行和交换信息</strong></p>\n<p><strong>2. 程序是一个在时间上严格有序的指令集合</strong></p>\n<p><strong>3. 在单道程序设计下，系统具有的特点</strong></p>\n<p>a. 资源的独占性</p>\n<p>b. 执行的顺序性</p>\n<p>c. 结果的再现性</p>\n<p><strong>4. 在多道程序设计环境下，系统具有：</strong></p>\n<p>a. 执行的并发性</p>\n<p>b. 相互的制约性</p>\n<p>c. 状态的多变性（不可再现性）</p>\n<p><strong>5. 并发、并行、串行</strong></p>\n<p>a. 从宏观上看是并行，同时在内存的多个程序都在执行着，互不影响</p>\n<p>b. 从微观上看是串行，由于 CPU 在任何时刻只能执行一个程序，因此这些程序轮流占用 CPU，交替执行着</p>\n<p>c. 我们把 “逻辑上相互独立的程序，在执行时间上相互重叠，一个程序的执行还没有结束，另一个程序的执行已经开始” 的这种特性称为程序执行的并发性</p>\n<p><strong>6. 对进程的描述</strong></p>\n<p>a. 进程是程序的一次执行过程</p>\n<p>b. 进程的运行活动是建立在某个数据集合上的</p>\n<p>c. 进程是在获得资源的基础上从事自己的运行活动</p>\n<p><strong>7. 进程的特征</strong></p>\n<p>结构特征、动态性、并发性、独立性、异步性</p>\n<p>进程是一个动态的概念</p>\n<p>不同进程可以执行同一个程序</p>\n<p>每一个进程都有自己的生命周期</p>\n<p>进程之间具有并发性，进程间会相互制约</p>\n<p><strong>8. 程序和进程的区别</strong></p>\n<p>a. 程序是指令的有序集合，是静态的，进程是程序在处理机上的一次执行过程，是动态的。程序的存在时永久的，而进程是有生命周期的，它因创建而产生，因调度而运行，因撤销而消亡</p>\n<p>b. 进程是程序的一次执行过程，程序是进程赖以存在的基础</p>\n<p>c. 进程具有并发性，而程序并发执行会失去可再现性</p>\n<p>d. 进程是系统分配和调度的独立单位，进程由程序、数据集合和进程控制块组成</p>\n<p><strong>9. 系统进程的使用级别高于用户进程</strong></p>\n<p><strong>10. 进程的状态</strong></p>\n<p>创建、就绪、运行、阻塞</p>\n<p>a. 一个进程从运行状态变为就绪状态，一定会引起另一个进程从就绪变为运行</p>\n<p>b. 一个进程从运行状态变为阻塞状态，一定会引起另一个进程从运行状态变为就绪状态；这种因果变迁绝对不可能发生，因为一个 CPU 不可能真正同时运行两个进程</p>\n<p>c. 一个进程从阻塞状态变为就绪状态，不一定会引起另一个进程从就绪状态变为运行状态</p>\n<p><strong>11. 进程的三个组成部分：程序、数据集合、进程控制块（PCB）</strong></p>\n<p><strong>12. 进程控制块是进程存在的唯一标示</strong></p>\n<p>a. 作用：通过 PCB，是原来不能独立运行的程序，成为一个可以独立运行的基本单位，一个能够并发执行的进程</p>\n<p>b. 其中的信息：进程标识符、处理机状态、进程调度信息、进程控制信息</p>\n<p><strong>13. 操作系统中把做出 “决定把 CPU 分配给谁用” 的程序称为 “进程调度程序”</strong></p>\n<p><strong>14. 常用的进程调度算法：</strong></p>\n<p>a. 先来先服务调度算法</p>\n<p>b. 时间片轮转调度算法：为就绪队列中的每一个进程分配一个称为 “时间片” 的时间段，它是允许该进程占用 CPU 的最长时间长度</p>\n<p>c. 优先数调度算法：优先数高的先调度，若相同则先来先服务</p>\n<p>d. 多级队列调度算法：时间片调度和优先数调度算法的结合</p>\n<p><strong>15. 进程调度程序的主要功能</strong></p>\n<p>a. 记录系统中所有进程的有关情况，比如进程的当前状态，优先数等</p>\n<p>b. 确定分配处理机的算法</p>\n<p>c. 完成处理机的分配</p>\n<p>d. 完成处理机的回收</p>\n<p><strong>16. 把处理剂分配给进程后，还有一个允许它占用多长时间的问题，有两种处理方式，一种是不可剥夺方式，另一种是剥夺方式</strong></p>\n<p><strong>17. 为了对进程进行有效的管理和控制，操作系统要提供若干基本的操作以便能创建进程、撤销进程、阻塞进程、唤醒进程，把具有这种特性的程序称为 “原语”，原语的不可分割性，通常利用屏蔽中断的方法</strong></p>\n<p><strong>18. 程序接口：操作系统在程序一级给予用户的支持</strong></p>\n<p>命令接口：操作系统在控制一级给予用户的支持</p>\n<p><strong>19.CPU 指令系统中的指令分为两类</strong></p>\n<p>a. 操作系统和用户都能使用的指令，非特权指令</p>\n<p>b. 只能由操作系统使用的指令，特权指令</p>\n<p><strong>20.CPU 的两种工作状态：管态、目态</strong></p>\n<p>a. 当 CPU 处于管态时，可以执行包括特权指令在内的一切机器指令</p>\n<p>b. 当 CPU 处于目态时，禁止使用特权指令</p>\n<p><strong>21. 访管指令</strong></p>\n<p>系统调用命令的程序属于操作系统，它应该在管态下执行</p>\n<p>用户程序只有通过计算机系统提供的访管指令才能实现由目态转为管态，进而调用这些功能程序的目的</p>\n<p>访管指令属于非特权指令，功能是执行它就会产生一个软中断，促使中央处理机由目态转为管态，进入操作系统并处理该中断</p>\n<p><strong>22. 从功能上看，可以把系统调用命令分为五大类：</strong></p>\n<p>a. 一是关于进程管理和控制的</p>\n<p>b. 二是关于外部设备输入 / 输出的</p>\n<p>c. 三是关于磁盘文件管理的</p>\n<p>d. 四是关于访问系统信息的</p>\n<p>e. 五是关于存储申请与释放的</p>\n<p><strong>23. 从形式上看，操作系统提供的系统调用与一般的过程调用（子程序调用）相似，但它们有着明显 的区别</strong></p>\n<p>作业管理：</p>\n<ol>\n<li>\n<p>把一个作业提交给系统时，系统要开辟一个作业控制块 JCB，以便随时记录作业的信息</p>\n</li>\n<li>\n<p>被系统接纳的作业，在没有投入运行之前，称为后备作业。这些作业存放在辅助存储器中，并由他们的 JCB 连接在一起，形成所谓的后备作业队列</p>\n</li>\n<li>\n<p>作业调度：按照某种规则，从后备作业队列中挑选作业进入内存，参与处理机的竞争，这个过程称为作业调度</p>\n</li>\n<li>\n<p>作业的状态：</p>\n</li>\n</ol>\n<p>a. 提交状态：进入辅助存储器，作业的信息还没有全部进入系统，系统也没有为它建立 JCB，感知不到它的存在</p>\n<p>b. 后备状态：建立起了 JCB，并将 JCB 排到后备作业队列中</p>\n<p>c. 运行状态：（阻塞、运行、就绪）都属于运行状态</p>\n<p>d. 完成状态：也是一个暂时性的状态</p>\n<ol start=\"5\">\n<li>作业的调度算法：</li>\n</ol>\n<p>a. 先来先服务：以作业进入后备作业队列的先后次序</p>\n<p>周转时间 = 完成时间 - 到达时间</p>\n<p>注：若分配一定的内存，且不允许作业在内存中移动时，要考虑所占内存大小</p>\n<p>b. 短作业优先：从后备作业队列中挑选所需 CPU 时间最少且资源能够得到满足的作业</p>\n<p>注：如果所有作业 “同时” 到达后备作业队列，那么采用短作业优先的作业调度算法总会获得最小的平均周转时间</p>\n<p>c. 响应比高着优先：先调度响应比高着</p>\n<p>响应比 = 已等待时间 / 所需 CPU 时间</p>\n<ol start=\"6\">\n<li>在确定作业调度算法时应注意的问题：</li>\n</ol>\n<p>a. 公平对待后备作业队列中的每一个作业，避免无故或无限期的延迟一个作业的执行，使各类用户感到满意</p>\n<p>b. 使进入内存的多个作业，能均衡地使用系统中的资源，避免出现有的资源没有作业使用，有的资源却被多个作业争抢的 “忙闲” 不均的情况</p>\n<p>c. 力争在单位时间内为尽可能多的作业提供服务，提高整个系统的吞吐能力</p>\n<h1 id=\"第三章-存储管理\"><a class=\"markdownIt-Anchor\" href=\"#第三章-存储管理\">#</a> 第三章 存储管理</h1>\n<ol>\n<li>\n<p>计算机操作系统的存储器：CPU 寄存器，主存，辅存</p>\n</li>\n<li>\n<p>在考虑计算机存储器的设计时，必须顾及</p>\n</li>\n</ol>\n<p>a. 价格、容量、访问时间</p>\n<p>b. 存取时间越快，价格越高，容量越小</p>\n<ol start=\"3\">\n<li>高速缓存：介于寄存器和存储器之间的存储器，主要用于备份主存中较常用的数据，以减少处理机对主存储器的访问次数，提高程序执行速度</li>\n</ol>\n<p>高速缓存容量远大于寄存器，比内存约小两到三个数量级左右</p>\n<p>为了缓和内存与处理机（CPU）速度的不匹配</p>\n<ol start=\"4\">\n<li>字（字长）：一次传送数据的长度 {16、32、64…} 依系统而定</li>\n</ol>\n<p>（主）内存储器和高速缓存之间是以 “块” 为单位传递数据的</p>\n<p>高速缓存与 CPU 之间则以 “字” 为单位传递数据</p>\n<ol start=\"5\">\n<li>存储器管理的功能：</li>\n</ol>\n<p>a. 内存的分配与回收</p>\n<p>b. 存储的保护和共享</p>\n<p>c. 地址定位</p>\n<p>d. 存储扩充</p>\n<ol start=\"6\">\n<li>\n<p>内存储器由一个个存储单元组成，一个存储单元可存放若干个二进制的位（bit），8 个二进制位被称为一个字节（byte）</p>\n</li>\n<li>\n<p>在操作系统中，把用户程序指令中的相对地址变为所在绝对地址空间中的绝对地址的这个过程，称为地址重定位</p>\n</li>\n<li>\n<p>地址的定位方式：</p>\n</li>\n</ol>\n<p>a. 绝对定位方式：是在程序装入内存之前，程序指令中的地址就已经是绝对地址，已经正确地反映了它将要进入的存储区的位置，不适用于多道程序设计环境</p>\n<p>b. 静态重定位（多道程序环境下）</p>\n<p>根据内存的具体情况将装入模块装入到内存的适当位置，会使装入模块中的所有逻辑地址与实际装入内存后的物理地址不同。</p>\n<p>这种地址重定位是在程序执行前完成的</p>\n<p>c. 动态重定位</p>\n<p>将地址重定位的时间推迟到程序执行时再进行</p>\n<p>所以装入内存的所有地址都仍是逻辑地址</p>\n<p>连续分配存储方式 ：</p>\n<ol>\n<li>单一连续分配（静态重定位）</li>\n</ol>\n<p>a. 单道程序环境下，总体上把内存储器分为两个分区：系统区和用户区</p>\n<p>b. 系统总是把整个用户区分配给一个用户使用，把分配给了用户但未被使用的区域称为 “内部碎片”</p>\n<p>c. 单一连续分区存储管理的缺点：</p>\n<p>a) 由于每次只能有一个进入内存，故它不适用于多道程序设计，工作效率不高，资源利用率低</p>\n<p>b) 只要作业比用户区小，在用户区里就会形成碎片，造成资源浪费</p>\n<p>c) 大作业无法在小内存中运行</p>\n<p>d. 为缓解大作业小内存的情况提出覆盖技术和对换技术</p>\n<p>a) 覆盖技术：允许一个作业的若干个程序段使用同一个存储区</p>\n<p>b) 对换技术：以辅助存储器作为内存的后援（硬盘）</p>\n<ol start=\"2\">\n<li>固定分区存储管理（静态）：分区数目、大小固定</li>\n</ol>\n<p>a. 预先把内存储器中可供分配的用户区划分成若干个连续分区，每个分区的尺寸可以相同，可以不同。每个分区中只允许装入一个作业运行，系统可以为每一个分区设置一个后备作业队列，一个作业到达时，总是进入到 “能容纳该作业的最小分区” 的那个后备队列中去排队</p>\n<p>b. 分区的分配与释放方案：</p>\n<p>a) 在队列中挑选出第一个可容纳的作业进入</p>\n<p>i. 优点：选择效率高</p>\n<p>ii. 缺点：小作业 -&gt; 大内存</p>\n<p>b) 在这个队列中进行搜索，找到这个分区能够容纳的最大的那个作业，让它进入运行</p>\n<p>i. 优点：存储空间利用率高，产生内部碎片尽可能的小</p>\n<p>ii. 缺点：选择效率低</p>\n<p>c) 在系统中至少保留一个小的分区，以避免因为运行小作业而被迫分配打分去的发生</p>\n<p>d) 为具体管理各个分区，并建立一个 “分区分配表”，其中包括每个分区的起始位置大小及状态</p>\n<p>c. 特点</p>\n<p>a) 它是最简单的，具有 “多道” 色彩的存储管理方案，提高资源利用率</p>\n<p>b) 当把一个分区分配给某个作业时，该作业的程序将一次性的全部装入到分配给他的连续分区里</p>\n<p>c) 静态重定位，在分区内的程序不能随意移动</p>\n<p>d. 缺点</p>\n<p>a) 进入分区的作业尺寸不见得与分区的长度相吻合，势必产生内部碎片，引起资源的浪费</p>\n<p>b) 如果到达作业的尺寸比任何一个分区的长度都大，它就无法运行</p>\n<ol start=\"3\">\n<li>可变分区存储管理：</li>\n</ol>\n<p>分区的边界划分随作业的需求可变，分区的数目随着进入作业的多少可变，消灭了内部碎片（可能会产生内部碎片）。</p>\n<p>外部碎片是指无法分配给用户使用的存储区</p>\n<p>a. 基本思想：在作业要求装入内存储器时，如果当时内存储器中有足够的存储空间满足该作业的需求，就划分出一个与作业相对地址空间同样大小的分区，并分配给它</p>\n<p>b. 要解决的问题</p>\n<p>a) 采用一种新的地址重定位技术，动态地址重定位，以便程序能够在内存储器中随意移动，为空闲区的合并提供保证</p>\n<p>b) 记住系统中各个分区的使用情况</p>\n<p>c) 给出分区分配算法</p>\n<p>c. 地址动态重定位过程（在程序执行时动态完成）</p>\n<p>a) 为实施地址动态重定位，硬件要增加一个地址转换机构，这个机构一般由地址转换线路和一个定位寄存器（基址寄存器）组成</p>\n<p>b) 地址的静态重定位和动态重定位的比较</p>\n<p>i. 地址转换时刻：静态重定位是在程序运行之前完成地址转换的，而动态重定位是在程序执行时完成</p>\n<p>ii. 谁来完成任务：静态重定位是由软件完成地址转换工作的，而动态重定位则是由一套硬件提供的地址转换机构来完成</p>\n<p>iii. 完成的形式：静态重定位是在装入时一次性集中地把程序指令中所有要转换的地址加以转换；而动态重定位则是每执行一条执行时，就对其地址加以转换</p>\n<p>iv. 完成的结果：实施静态重定位，原来的指令地址部分被修改了，而动态重定位只是按照所形成的地址去执行这条指令，并不对指令本身做任何修改</p>\n<p>d. 空闲区的合并</p>\n<p>e. 分区的管理</p>\n<p>a) 表格法：一张已分配表，一张空闲表（分区号，分区大小，分区起始地址、状态）</p>\n<p>b) 单链表法：一个存放该分区的长度，另一个存放它下一个空闲分区的起始地址</p>\n<p>c) 双链表法：还存放上一个空闲区起始地址</p>\n<p>f. 空闲分区的分配算法</p>\n<p>a) 最先适应算法：要求空闲分区链以地址递增的次序链接（对大作业不利）</p>\n<p>b) 最佳适应算法：每次为作业分配内存时，总是把能满足要求，又是最小的空闲分区分配给作业，避免 “大材小用” 按其容量</p>\n<p>c) 最坏适应算法：挑选一个最大的空闲区，从中分割一部分存储空间给作者使用，以至于存储器中缺乏大的空闲分区，照顾中小作业的需求</p>\n<p>d) 循环首次适应算法：从上次分配的位置之后开始查找</p>\n<p>g. 可变分区存储管理的特点</p>\n<p>a) 作业一次性的全部装入到一个连续的存储分区中</p>\n<p>b) 分区是按照作业对存储的需求划分的，所以不会出现内部碎片</p>\n<p>c) 为了确保作业能够在内存中移动，要有硬件的支持，实行指令地址的动态重定位</p>\n<p>h. 缺点：</p>\n<p>a) 仍然没有解决小内存裕兴大作业的问题，只要作业的存储需求大于系统提供的整个用户区，该作业就无法投入运行</p>\n<p>b) 虽然避免了内部碎片，但有可能出现极小的翻去暂时分配不出去的情形，引起了外部碎片，</p>\n<p>c) 为了形成大的分区，可变分区存储管理通过移动程序来达到分区合并的目的，然而程序的移动是很花费时间的，增加了系统在这方面的投入与开销</p>\n<ol start=\"4\">\n<li>分页式存储管理：</li>\n</ol>\n<p>需要两次访问内存，目的是提高内存利用率</p>\n<p>a. 分页式储存管理是将固定分区方法与动态重定位技术结合在一起，需要硬件支持</p>\n<p>基本思想：首先把整个内存储器划分成大小相等的许多分区，每个分区称为 “一块”</p>\n<p>b. 在分页式存储管理中，块是存储分配的单位</p>\n<p>a) 用户作业仍然是相对于 “0” 进行编址，形成一个连续的相对地址空间</p>\n<p>b) 用户程序相对地址空间中的每一个分区被称为 “页”，用户相对地址空间中的每一个相对地址，都可以用（页号，页内位移）这样的数对来表示</p>\n<p>i. 物理地址 = 页的大小 * 页号 + 页内位移</p>\n<p>ii. 页号 = 相对地址 / 块尺寸</p>\n<p>iii. 页内位移 = 相对地址 % 块尺寸</p>\n<p>c. 页与块对应关系表称为 “页表”</p>\n<p>a) 快速寄存器组单独起名为 “相联寄存器”，简称 “快表”</p>\n<p>b) 快表与页表联合工作，先查找快表，若无再查找页表并把数据写入快表</p>\n<p>c) （访问页表时间 + 访问一次内存时间）<em>命中率 + 访问快表时间</em>命中率 = 平均内存存取时间</p>\n<p>d) 页面尺寸大多选在 512byte 到 64kb 之间</p>\n<p>d. 特点：</p>\n<p>a) 内存储器实现被划分成相等尺寸的块，它是进行存储分配的单元</p>\n<p>b) 用户作业的相对地址空间按照块的尺寸划分成页，这是在系统内部进行的，用户感觉不到</p>\n<p>c) 相对地址空间中的页可以进入内存中的任何一个空闲块，并且分页式存储管理实行的是动态重定位，因此它打破了一个作业必须占据连续的存储空间的限制，作业在不连续的存储区里，也能够得到正确的运行</p>\n<p>e. 缺点：</p>\n<p>a) 平均每一个作业要浪费半页大小的存储块，会产生内部碎片</p>\n<p>b) 作业虽然可以不占据连续的存储区，但是每次仍然要求一次全部进入内存。因此，如果作业很大，其存储需求大于内存，仍然存在小内存不能运行大作业的问题</p>\n<ol start=\"5\">\n<li>分段式存储管理：</li>\n</ol>\n<p>a. 目的：方便用户使用编程，存储共享，存储保护，动态增长，动态链接</p>\n<p>b. 要求用户将自己的整个作业程序以多个相互独立的称为 “段” 的地址空间提交给系统，每个段都是一个从 “0” 开始的一维地址空间，长度不一，操作系统按照段长为作业分配内存空间</p>\n<p 段号，段内位移=\"\">c. 段表：段号、段长、该段在内存的基址（起始地址）</p>\n<p>a) 物理地址 = 段的起始地址 + 段内地址</p>\n<p>b) 逻辑地址 = 段号 + 段内地址</p>\n<p>d. 分段与分页的区别：</p>\n<p>a) 页是信息的物理单位，段是信息的逻辑单位</p>\n<p>i. 分页提高内存的利用率，仅仅是系统管理上的需要，用户不可见。段是信息的逻辑单位，它通常包括的是一组意义相对完整的信息，分段段的目的主要在于能更好地满足用户的需要</p>\n<p>b) 页的尺寸由系统决定，段的尺寸因段而异</p>\n<p>i. 段的长度取决于用户编写的程序，通常由编译程序在对源程序进行编译时根据信息的性质来划分</p>\n<p>c) 页的地址空间是一维的，段的地址空间是二维的</p>\n<p>i. 分页：用户必须通过链接编辑程序，把各程序段链接成一个相对于 0 编址的线性空间，程序中是通过地址编号来确定空间中的位置的。因此用户向系统提供的是一个一维的逻辑地址空间。</p>\n<p>ii. 分段：用户不把各程序段链接成一个相对于 0 进行编制的一维线性空间，各程序段之间是通过 {段号，段内位移} 进行访问的。因此，用户向系统提供的是一个二维的逻辑地址空间</p>\n<ol start=\"6\">\n<li>段页式存储管理：（三次访问内存）</li>\n</ol>\n<p>a. 基本原理：分段和分页原理的结合，即先将用户程序分成若干个段，再把每个段分成若干个页，并为每一个段赋予一个段名。</p>\n<p>a) 作业地址空间结构：主程序段，子程序段，数据段</p>\n<p>b) 地址结构：段号，段内页号，页内地址</p>\n<p>b. 系统设置了位示图、段表和页表，记录主存的使用情况和作业分配情况</p>\n<p>a) 逻辑地址 = 段号 + 页号 + 页内位置</p>\n<p>b) 块号 * 块长 + 页内地址</p>\n<p>c. 虚拟存储器：是具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统，其逻辑容量由内存容量和外存容量之和所决定，其运行速度接近于内存速度。</p>\n<p>a) 特征：多次性、对换性、虚拟性、离散性</p>\n<p>d. 请求分页式存储管理（需要硬件支持）</p>\n<p>a) 是基于分页式存储管理的一种虚拟存储器</p>\n<p>“请求分页式” 是指当程序运行中需要某一页时，再把它从辅助存储器里调入内存使用，解决了小内存与大作业的矛盾，但会产生内部碎片</p>\n<p>b) 缺页中断是指在指令执行期间，若发现所要访问的指令或数据不在内存时，便立即产生和处理缺页中断信号，以便能及时将所缺之页面调入内存</p>\n<p 缺页中断率=\"缺页次数/页面总数\">e. 缺页中断与一般中断的区别</p>\n<p>a) 缺页中断是在执行一条指令中间时产生的中断，并立即去处理，一般中断则是一条指令执行完毕后，当发现有中断请求时，才去响应和处理</p>\n<p>b) 缺页中断处理完成后，仍返回到原指令去执行，因为那条指令并未执行；而一般中断则是到下一条指令去执行，因为上一条指令已经执行完毕了</p>\n<p>f. 影响缺页中断次数的因素：</p>\n<p>a) 分配给作业的内存块数</p>\n<p>b) 页面尺寸</p>\n<p>c) 程序的实现</p>\n<ol start=\"7\">\n<li>页面淘汰（置换）算法：</li>\n</ol>\n<p>页面淘汰是由缺页中断引起的，但缺页中断不见得一定引起页面淘汰</p>\n<p>a. 先进先出页面淘汰（置换）算法（FIFO）</p>\n<p>淘汰最先进入内存的页面 （3 个内存块都为空，3 次缺页中断）</p>\n<p>b. 最近最久未用页面淘汰（置换）算法（LRU）</p>\n<p>总是把最长时间未被访问过的页面淘汰出去 （需要寄存器和栈）</p>\n<p>c. 最近最少用页面淘汰（置换）算法（LFU）</p>\n<p>总是把当前使用的最少的页面淘汰出去</p>\n<p>为每个内存中的页面设置一个计数器（移位寄存器） 加 1</p>\n<p>d. 最优（最佳）页面淘汰（置换）算法（OPT）</p>\n<p>把以后不再使用的或最长时间内不会用到的页面淘汰出去（理论上，不会实现）</p>\n<p>注：对于 FIFO 页面淘汰算法，有时增加分配给作业的可用内存块数，它的缺页次数反而上升，通常称为异常现象</p>\n<h1 id=\"第四章-设备管理\"><a class=\"markdownIt-Anchor\" href=\"#第四章-设备管理\">#</a> 第四章 设备管理</h1>\n<p SPOOLing技术=\"\">1．“设备” 泛指计算机系统中的各种外部设备，外设（即主机以外的其他所有设备）在众多的 I/O 设备中，并不是所有的设备都是可以共享的，可以借助于磁盘，把只能独享的设备变为共享，这就是所谓的 “虚拟设备”</p>\n<p>2．设备是指计算机中用以在机器之间进行传送和接收信息，完成用户输入 / 输出（I/O）操作的那些部件。比如磁盘、磁带、打印机、显示器、鼠标、键盘・・・・・・</p>\n<p>3．计算机 I/O 系统的组织结构：</p>\n<p>（1）底层是具体的设备和硬件接口</p>\n<p>（2）中间是系统软件（与设备相关软件、与设备无关软件）</p>\n<p>（3）用户程序</p>\n<p>4．I/O 设备一般是由执行 I/O 操作的机械部分和执行控制 I/O 的电子部件组成</p>\n<p>（1）执行 I/O 操作的机械部分就是一般的 I/O 设备</p>\n<p>（2）执行控制 I/O 的电子部件称为设备控制器或适配器</p>\n<p>① 为了能够使 CPU 设备控制器中的各个寄存器进行通信，通常采用 “单独的 I/O 空间” 和 “内存映射 I/O” 两种方法</p>\n<p>② 设备控制器是 CPU 与外围设备之间的接口，是一个可编址设备，每一个地址对应一个设备</p>\n<p>功能：</p>\n<p>Ø 接收和识别命令</p>\n<p>Ø 数据交换</p>\n<p>Ø 标识和报告设备的状态</p>\n<p>Ø 地址识别</p>\n<p>Ø 数据缓冲区</p>\n<p>Ø 差错控制</p>\n<p>组成：</p>\n<p>Ø 设备控制器与处理机（CPU）的接口</p>\n<p>Ø 设备控制器与设备的接口</p>\n<p>Ø I/O 逻辑：用于实现对设备的控制</p>\n<p>5．设备驱动程序：</p>\n<p>6．设备处理方式：</p>\n<p>（1）为每一类设备设置一个进程，专门用于执行这类设备的 I/O 操作</p>\n<p>（2）在整个系统中设置一个 I/O 进程，专门用于执行系统中所有各类设备的 I/O 操作</p>\n<p>（3）不设置专门的设备处理进程，而只为各类设置相应的设备驱动程序，供用户或系统进程调用</p>\n<p>7．设备驱动程序的处理过程</p>\n<p>（1）将抽象要求转换为具体要求</p>\n<p>（2）对服务请求进行校验，即检查 I/O 请求的合法性</p>\n<p>（3）检查设备的状态</p>\n<p>（4）传送必要的参数</p>\n<p>（5）启动 I/O 设备</p>\n<p>（6）工作方式的设置</p>\n<p>I/O 接口程序：是操作系统中与设备无关的软件，它从上层接收用户对设备提出的 I/O 请求，然后负责吧 I/O 请求转变成所需要的 I/O 命令，调用具体的设备驱动程序去执行</p>\n<p>系统都是用主设备号和次设备号组成 “逻辑设备名”</p>\n<p>操作系统提供的设备无关性的优点：</p>\n<p>ü 方便用户</p>\n<p>ü 提高设备的利用率</p>\n<p>8．计算机设备的分类</p>\n<p>（1）基于设备的从属关系</p>\n<p>a. 系统设备（键盘、显示器、打印机、磁盘驱动）</p>\n<p>b. 用户设备</p>\n<p>（2）基于设备的分配特性</p>\n<p>a. 独享设备（打印机）</p>\n<p>b. 共享设备</p>\n<p>c. 虚拟设备（SPOOLing 技术）</p>\n<p>（3）基于设备的工作特性</p>\n<p>a. 输入 / 输出设备（字符设备）</p>\n<p>b. 存储设备（块设备） 磁盘、磁带</p>\n<p>（4）按信息交换的单位</p>\n<p>a. 块设备：用于存储信息，属于结构设备。磁盘、磁带（以块为单位传送信息）</p>\n<p>b. 字符设备：以单个字符为单位来传送信息。 键盘</p>\n<p>9．设备管理的目标</p>\n<p>a. 提高外部设备的利用率</p>\n<p>b. 为用户提供便利、统一的使用界面</p>\n<p>10．设备管理的功能</p>\n<p>a. 提供一组 I/O 命令</p>\n<p>b. 进行设备的分配和回收</p>\n<p>c. 对缓冲区进行管理</p>\n<p>d. 实现真正的 I/O 操作</p>\n<p>11．输入输出管理步骤</p>\n<p>（1）用户在程序中使用系统提供的输入 / 输出命令发出 I/O 请求</p>\n<p>（2）输入输出管理程序接受这个请求</p>\n<p>（3）“设备驱动程序” 来具体完成所要求的的 I/O 操作</p>\n<p>（4）实现设备中断处理程序来处理这个请求</p>\n<p>设备的输入输出管理程序由 3 块内容组成：接受用户的 I/O 请求，组织管理输入输出进行，输入输出的善后处理</p>\n<p>设备控制：</p>\n<ol>\n<li>\n<p>设备控制块 DCB 中存放的是一台具体设备的有关信息，找到一个设备的 DCB，就得到了该设备的特性，各种参数，使用情况等，所以 DCB 是设备管理中最重要的一条数据结构</p>\n</li>\n<li>\n<p>独享设备中具有排他性，只能采取 “静态分配” 的策略</p>\n</li>\n</ol>\n<p>a. 静态分配：用户作业开始之前，由系统一次分配给该作业所需的设备，控制器和通道，不会发生死锁</p>\n<p>b. 动态分配：在进程执行过程中进行的设备分配，可能造成死锁</p>\n<p>对独享设备采用的分配算法：</p>\n<p>v 先来先服务</p>\n<p>v 优先级高者先服务</p>\n<ol start=\"3\">\n<li>共享磁盘的调度</li>\n</ol>\n<p>磁盘是一种典型的共享存储设备，允许多个作业进程同时使用，而不是让一个作业在整个运行期间独占。“同时使用” 是指当一个作业进程暂时不用时，其他作业进程就可以使用。每一个时刻只有一个作业用</p>\n<ol start=\"4\">\n<li>调度算法</li>\n</ol>\n<p>a. “先来先服务” 调度算法（并不理想）（移臂调度，减少查找时间）</p>\n<p>以 I/O 请求到达的先后次序作为磁盘调度的顺序</p>\n<p>b. “最短查找时间” 调度算法</p>\n<p>把距离磁头当前位置最近的 I/O 请求作为下一次调度的对象</p>\n<p>c. “电梯” 调度算法（SCAN）</p>\n<p>总是沿着此案移动臂的移动方向选择距离磁头当前位置最近的 I/O 请求，作为下一次调度的对象</p>\n<p>d. “单向扫描” 调度算法（循环扫描 CSCAN）</p>\n<p>总是从 0 号柱面开始往里移动移动臂，遇到有 I/O 请求就进行处理，直到到达最后一个请求柱面，然后移动臂立即带动磁头不做任何服务地快速返回到 0 号柱面，开始下一次扫描</p>\n<p>对 I/O 设备的控制方式（数据传输方式）</p>\n<ol>\n<li>程序循环测试方式（程序查询式）</li>\n</ol>\n<p>是指用户进程使用 start 指令启动设备后，不断地执行 test 指令，去测试所启动设备的状态寄存器。只有在状态寄存器出现了所需要的状态后，才停止测试工作，完成输入 / 输出。</p>\n<p>数据寄存器：用来存放传输的数据</p>\n<p>状态寄存器：用来记录设备当前所处状态</p>\n<ol start=\"2\">\n<li>中断方式</li>\n</ol>\n<p>所谓 “中断” 是一种使 CPU 暂时中止正在执行的程序而转去处理特殊时间的操作。</p>\n<p>引起中断的时间称为中断源。</p>\n<p>程序中产生的中断，由 CPU 的某些错误结果（如，计算机溢出）产生的中断称为 “内中断”，由外部设备控制器引起的中断称为 “外中断”</p>\n<ol start=\"3\">\n<li>直接存储器存取方式（DMA 方式）</li>\n</ol>\n<p>特点：能使 I/O 设备直接和内存储器进行成批数据的快速传输。（单位：块数据）</p>\n<p>DMA 控制器包括四个寄存器：数据寄存器，状态寄存器，地址寄存器，字节计数器</p>\n<p>DMA 控制器的组成：主机与 DMA 控制器的接口；DMA 控制器与块设备的接口；I/O 控制逻辑</p>\n<ol start=\"4\">\n<li>通道方式</li>\n</ol>\n<p>通道方式能够使 CPU 彻底从 I/O 中解放出来。CPU 进行善后处理和启动。</p>\n<p>通道是一个独立于 CPU 的，专门用来管理输入 / 输出操作的处理机。</p>\n<p>通道是通过执行通道程序并与设备控制器共同实现对 I/O 设备的控制的。</p>\n<p>它规定了设备应该执行的各种操作的顺序。由一系列通道指令所构成，CPU 对 I/O 请求只去做启动和善后处理工作，输入 / 输出的管理以及数据传输等事宜，全部由通道独立完成。</p>\n<p>缓冲：</p>\n<ol>\n<li>原因：</li>\n</ol>\n<p>a. 缓和 CPU 与 I/O 设备间速度不匹配的矛盾</p>\n<p>b. 减少对 CPU 的中断频率，放宽对 CPU 中断响应时间的限制</p>\n<p>c. 解决数据粒度不匹配的问题</p>\n<p>d. 提高 CPU 和 I/O 设备之间的并行性</p>\n<ol start=\"2\">\n<li>缓冲的实现</li>\n</ol>\n<p>a. 采用专门的硬件寄存器，比如设备控制器里的数据寄存器，“硬件缓冲”</p>\n<p>b. 在内存储器中开辟出 n 个单元，作为专用的 I/O 缓冲区，以便存放输入 / 输出的数据，这种缓冲区就是 “软件缓冲”</p>\n<p>c. 根据缓冲区的个数：单缓冲区、双缓冲区、多缓冲区、缓冲池</p>\n<ol start=\"3\">\n<li>虚拟设备</li>\n</ol>\n<p>a. 通过多道程序技术可将一台物理 CPU 虚拟为多台逻辑 CPU，需要硬件的支持。作为后援的硬盘（大容量），具有设备与 CPU 并行工作的能力</p>\n<ol start=\"4\">\n<li>SPOOLing 技术</li>\n</ol>\n<p>a. 在主机的直接控制下，实现以前的脱机输入 / 输出功能，此时的外围操作与 CPU 对数据的处理同时进行，我们把这种在联机情况下实现的同时外围操作的技术称为 SPOOLing 技术，或假脱机技术</p>\n<p>b. SPOOLing 技术是对脱机输入 / 输出系统的模拟。SPOOLing 系统建立在通道技术和多道程序技术的基础上，以高速随机外存（通常为磁盘）为后援存储器</p>\n<ol start=\"5\">\n<li>设备无关性：</li>\n</ol>\n<p>应用程序中所用的设备，不局限于使用某个具体的物理设备。为每个设备所配置的设备驱动程序是与硬件紧密相关的软件。为了实现设备独立性，必须再在设备驱动程序上设置一层软件，称为与设备无关的 I/O 软件或设备独立性软件</p>\n<ol start=\"6\">\n<li>操作系统中实现虚拟设备的软件功能模块由 3 部分组成</li>\n</ol>\n<p>a. 预输入程序</p>\n<p>b. 缓输出程序</p>\n<p>c. 井管理程序</p>\n<ol start=\"7\">\n<li>SPOOLing 系统由四部分组成</li>\n</ol>\n<p>a. 输入井和输出井</p>\n<p>在磁盘上开辟出来的两个存储区域，输入数据，输出数据</p>\n<p>b. 输入缓冲区和输出缓冲区</p>\n<p>在内存中开辟的两个缓冲区</p>\n<p>c. 输入进程和输出进程</p>\n<p>模拟外围控制机</p>\n<p>d. 井管理程序</p>\n<p>特点：</p>\n<p>Ø 提高了 I/O 的速度</p>\n<p>Ø 将独占设备改造为共享设备</p>\n<p>Ø 实现了虚拟设备的功能</p>\n<h1 id=\"第五章-文件管理\"><a class=\"markdownIt-Anchor\" href=\"#第五章-文件管理\">#</a> 第五章 文件管理</h1>\n<ol>\n<li>目标：提高外存储空间的利用率</li>\n</ol>\n<p>主要任务：对用户文件和系统文件进行管理，方便用户使用，并保证文件的安全性</p>\n<p>文件存储设备是以块为单位进行管理的</p>\n<ol start=\"2\">\n<li>\n<p>所谓 “文件” 是指具有完整逻辑意义的一组相关信息的集合，它是在磁盘上保存信息，而且能方便以后读取的方法，文件用符号名加以标识，这个符号名就被称为 “文件名”</p>\n</li>\n<li>\n<p>文件是指由创建者所定义的，具有文件名的一组相关元素的集合，可分为有结构文件和无结构文件两种。在有结构的文件中，文件由若干个相关记录组成而无结构文件则被看成是一个字符流。文件在文件系统中是一个最大的数据单位，它描述了对象集</p>\n</li>\n</ol>\n<p>文件属性：文件类型、文件长度、文件的物理位置、文件的建立时间（最后一次的修改时间）</p>\n<ol start=\"4\">\n<li>\n<p>文件名：在不同的系统之间，对文件名的规定是不同的。一个文件名是在创建该文件时由用户给出的，操作系统将向用户提供组成文件名的命名规则</p>\n</li>\n<li>\n<p>很多操作系统采用句点‘.’隔开成两部分的文件名形式，句点之前的部分称为文件名，句点后面的部分称为文件的 “扩展名”。又称后缀名，用于指示文件的类型</p>\n</li>\n</ol>\n<p>.bak 备份文件 .bas ABSIC 源程序 .bin 可执行的二进制文件</p>\n<p>.c C 源程序 .dat 数据文件 .doc 文档文件</p>\n<p>.hlp 帮助文件 .obj 目标文件 .pas Pascal 文件</p>\n<p>.txt 一般文本文件 .tmp 临时文件</p>\n<ol>\n<li>\n<p>文件被存在大容量的辅助存储器（外存）中，当用户需要使用时，就通过文件名把相应的文件读到内存</p>\n</li>\n<li>\n<p>“文件系统” 是指操作系统中与文件管理有关的那部分软件，被管理的文件，以及管理文件所需要的数据结构（目录、索引表・・・・・・）的总体</p>\n</li>\n<li>\n<p>对文件的分类</p>\n</li>\n</ol>\n<p>a. 按文件的性质和用途：系统文件、用户文件、库文件</p>\n<p>b. 按文件中数据的形式：源文件、目标文件、可执行文件</p>\n<p>c. 按存取控制属性分类：只执行文件、只读文件、读写文件</p>\n<p>d. 按文件的保护性质：只读文件、读写文件、可执行文件、不保护文件</p>\n<p>e. 按文件的保护期限：临时文件、档案文件、永久文件</p>\n<p>f. 按文件的存取方式：顺序存取文件、随机存取文件</p>\n<p>g. 按设备的类型：磁盘文件、磁带文件、打印文件</p>\n<p>h. 按文件的物理结构：连续文件、链接文件、索引文件</p>\n<p>i. 按文件的内容（组织形式和处理方式）：普通文件、目录文件、特殊文件</p>\n<p>j. 按文件的逻辑结构：流式文件、记录式文件</p>\n<ol start=\"4\">\n<li>文件的逻辑结构</li>\n</ol>\n<p>a. 从用户使用的角度出发组织的文件，被称为是文件的逻辑结构，一类是有结构的文件，这是指由一个以上的记录构成的文件，故又称为记录式文件</p>\n<p>b. 从文件的组织方式来分，可以分为顺序文件，索引文件，索引顺序文件</p>\n<p>c. UNIX 操作系统总是以流失作为文件的逻辑结构</p>\n<ol start=\"5\">\n<li>文件的物理结构</li>\n</ol>\n<p>a. 文件按不同的组织方式在辅存上存放，就会得到不同的物理结构，文件的物理结构有时也称为文件的 “存储结构”</p>\n<p>b. 文件在辅存（外存）上可以有 3 种不同的存放方式：连续存放、链接块存放以及索引表存放</p>\n<p>c. 对应地文件就有 3 种物理结构，分别叫做顺序结构，链接结构和索引结构，也叫作连续文件，串联文件，索引文件</p>\n<ol start=\"6\">\n<li>存放方式</li>\n</ol>\n<p>a. 连续存放 — 连续文件</p>\n<p>不足之处：</p>\n<p>v 必须预先知道文件的最大长度</p>\n<p>v 会造成磁盘碎片</p>\n<p>b. 链接块存放 — 串联文件</p>\n<p>不会因为磁盘碎片而浪费存储空间，但使用的指针要占去一些字节，每个磁盘块存储数据的字节数不再是 2 的幂，从而降低了系统的运行效率</p>\n<p>c. 索引表存放 — 索引文件</p>\n<ol start=\"7\">\n<li>文件的存取</li>\n</ol>\n<p>a. 顺序存取</p>\n<p>b. 随机存取</p>\n<ol start=\"8\">\n<li>磁盘空间的管理</li>\n</ol>\n<p>a. 磁盘是以块为单位进行分配的</p>\n<p>b. 磁盘与内存之间是以磁盘块为信息传输的单位</p>\n<p>c. 选定了块的大小，还要对它们进行管理，即要记住哪些已经分配，哪些仍然空闲。</p>\n<p>d. 常采用的磁盘存储空间管理方案有：位示图，空闲块表，空闲块链</p>\n<ol start=\"9\">\n<li>文件的操作：</li>\n</ol>\n<p>创建文件、删除文件、打开文件、关闭文件、读文件、写文件</p>\n<ol start=\"10\">\n<li>系统是通过文件的目录来管理文件的</li>\n</ol>\n<p>文件目录也是一种数据结构，用于标识系统中的文件及其物理地址</p>\n<ol start=\"11\">\n<li>为每一个文件开辟一个存储区，在它的里面记录着该文件的有关信息。</li>\n</ol>\n<p>我们把该存储区称为 “文件控制块”（FCB） 也是一个目录项</p>\n<p>随系统的不同，一个文件的 FCB 中所包含的内容及大小也不尽相同</p>\n<p>包含内容：</p>\n<p>Ø 文件名称</p>\n<p>Ø 文件在辅存中存放的物理位置</p>\n<p>Ø 文件的逻辑结构</p>\n<p>Ø 文件的物理结构</p>\n<p>Ø 文件的存取控制信息</p>\n<p>Ø 文件管理信息</p>\n<ol start=\"12\">\n<li>目录的层次结构</li>\n</ol>\n<p>如果把所有文件的 FCB 都登记在一个文件目录中，这样由文件名查文件目录项，直接就能够找到所需要的文件，那么就成这种文件目录为一级目录结构</p>\n<p>a) 优点：</p>\n<p>i. 简单，能实现目录管理中最基本的功能 — 按名存取</p>\n<p>b) 缺点：</p>\n<p>i. 查找速度慢，不允许重名，不便于实现文件共享</p>\n<p>二级目录结构：</p>\n<p>由 “主目录” 与 “用户目录” 二级构成，在主目录（根目录）中，每个目录项的内容只是给出文件主名以及它的目录所在的磁盘地址。在一个个用户目录中，才是由问价的呢 FCB 组成的目录，用户目录，实际上就是一级目录</p>\n<ol>\n<li>两级目录结构的优点：</li>\n</ol>\n<p>a. 提高了检索目录的速度</p>\n<p>b. 在不同的文件目录中，可以使用相同的文件名</p>\n<p>c. 不同用户还可使用不同的文件名访问系统中的同一个共享文件</p>\n<ol start=\"2\">\n<li>缺点：</li>\n</ol>\n<p>a. 若一个用户可以拥有很多文件，则查找时间仍然很长</p>\n<p>b. 用户无法对自己的文件进行再分类安排</p>\n<ol start=\"3\">\n<li>树型目录结构</li>\n</ol>\n<p>允许每个用户可以拥有多个目录，即在用户目录的下面可以再分子目录，子目录的下面还可以再有子目录。但每个文件目录中，只能有一个根目录，每个文件和每个目录都只能有一个父目录</p>\n<ol start=\"4\">\n<li>从根目录出发到具体文件所经过的各层名字，就构成了文件的 “路径名”，从根目录出发的这个路径名，也称为文件的 “绝对路径名”。</li>\n</ol>\n<p>文件的绝对路径名必须从根目录出发，且是唯一的，从分隔符开头</p>\n<p>在 UNIX 系统中，路径名各部分之间是用 “/” 分隔</p>\n<p>在 MS-DOS 系统中，路径各部分是用 “\\” 分隔</p>\n<p>在 MVLTICS 系统中，路径各部分之间是用 “&gt;” 分隔</p>\n<p>在当前目录下的文件的路径名，称为文件的相对路径名</p>\n<ol start=\"5\">\n<li>文件的 “共享” 是指一个文件可以被多个授权用户共同使用</li>\n</ol>\n<p>分两种：</p>\n<p>Ø 任何时刻只允许一个用户使用共享文件</p>\n<p>Ø 允许多个用户同时使用同一个共享文件，只进行读操作</p>\n<h1 id=\"第六章-进程间的制约关系\"><a class=\"markdownIt-Anchor\" href=\"#第六章-进程间的制约关系\">#</a> 第六章 进程间的制约关系</h1>\n<ol>\n<li>\n<p>在多道程序设计环境下，进程程序的执行具有并发性，在相同的前提条件下，两次执行的结果有可能不相同，使得一个进程对另一个进程的影响无法预测，在操作系统里把这种由于时间因素的影响而产生的错误称为：“与时间有关的错误”</p>\n</li>\n<li>\n<p>进程间具有两种制约关系：互斥和同步</p>\n</li>\n</ol>\n<p>a. 由于对共享资源的争夺，导致进程之间出现互斥关系</p>\n<p>b. 由于对任务的协调工作，导致进城之间出现同步关系</p>\n<ol start=\"3\">\n<li>把那些可以共享的资源（文件、队列、缓冲区、表格、变量・・・・・・）统称为共享变量或临界资源</li>\n</ol>\n<p>与一个共享变量（或共享资源）交往的多个进程，为了保证它们各自运行结果的正确性，当其中的一个进程正在对该变量（临界资源）进行操作时，就不允许其他进程同时对它操作。进程的这种制约关系被称为 “互斥”</p>\n<ol start=\"4\">\n<li>注意（互斥进程）</li>\n</ol>\n<p>a. 作为具有互斥关系的进程，它的一部分程序可能用于内部的计算以及内部的数据处理等，那么只有设计共享变量的那一部分程序，才真正需要保证互斥地执行，把进程程序中 “真正需要保证互斥执行” 的那一段程序（或在每个进程中访问临界资源的那段代码）称为该进程的临界区（临界段）</p>\n<p>b. 具有互斥关系的进程，并不关心对方的存在，即使对方不存在，自己也能够正确地运行</p>\n<p>c. 具有互斥关系的那些进程程序中的临界区，虽然都是针对同一个共享变量的程序，但在其上执行的操作可以相同也可以不同</p>\n<p>d. 进程的临界区是相对于某个共享变量而言的，不同共享变量的临界区之间，不存在互斥关系</p>\n<p>信号量及其定义在信号量上的 P、V 操作：</p>\n<ol>\n<li>如何来保证进程在临界区执行的互斥性，由信号量及其定义在信号量上的 P、V 操作具体完成，但遵循如下规则</li>\n</ol>\n<p>a. 如果有若干个进程希望进入临界区时，至少应该允许一个进入，而不能谁也进不去</p>\n<p>b. 每次只允许一个进程进入临界区</p>\n<p>c. 进入临界区的进程不能无限期地把持临界区</p>\n<ol start=\"2\">\n<li>同步</li>\n</ol>\n<p>a. 需要在某些点上协调相互的动作，谁先到达谁后到达是有顺序要求的</p>\n<p>b. 这些进程都应该了解对方的工作，对方如果不存在，或任何一方单独运行，就会出现差错</p>\n<p>c. 一方或双方的运行会直接地依赖于对方所产生的的信息，或发出的消息</p>\n<ol start=\"3\">\n<li>一个进程运行到某一点时，除非合作进程已经完成了某种操作或发来了信息，否则就必须暂时等待那些操作的完成或信息的到来。</li>\n</ol>\n<p>进程间的这种关系被称为 “同步”，暂停以取得同步的那一点称为 “同步点”，需要等待一个进程完成的操作或发送的信息，称为 “同步条件”</p>\n<ol start=\"4\">\n<li>一个信号量的建立必须经过说明，即应该准确说明 S 的意义和初值（不能为负）</li>\n</ol>\n<p>每个信号量都有相应的队列，在建立信号量时，队列为空</p>\n<p>可进行原子操作 P (wait)、V (signal) 操作</p>\n<ol start=\"5\">\n<li>信号量 S 上的 P 操作</li>\n</ol>\n<p>①　Vs = Vs-1，把当前信号量 S 的取值减 1</p>\n<p>②　若 Vs &gt;= 0，则调用进程继续运行，若 Vs &lt; 0，则调用进程由运行状态变为阻塞状态，到与该信号量有关的队列 Vq 上排队等待，直到其他进程在 S 上执行 V 操作将其释放为止</p>\n<ol start=\"6\">\n<li>信号量 S 上的 V 操作</li>\n</ol>\n<p>①　Vs = Vs + 1，把当前信号量 S 的取值加 1</p>\n<p>②　若 Vs &gt; 0，则调用进程继续执行，若 Vs &lt;= 0，则先从与该信号量有关的队列 Vq 上摘下一个等待进程，让它从阻塞状态变为就绪状态，到就绪队列里排队，然后调用进程继续执行</p>\n<p>注意：</p>\n<p>a. 设置的信号量初值一定是一个非负的整数。而运行过程中，信号量的取值就不再受 “非负” 所限了</p>\n<p>b. 只要进入了 P (S) 或 V (S)，这两个动作就必须顺序地做完，中间不能被打断，为保证执行时的不可分割性，常采用关、开中断的方法来具体实现信号量上的 P、V 操作</p>\n<p>c. 如果一个进程在做 P 操作后被阻塞，到关于信号量的队列上去排队等待，其含义是让进程的 PCB 到此队列上排队</p>\n<ol start=\"7\">\n<li>用 P、V 操作实现资源分配</li>\n</ol>\n<p>做 P 操作即是申请一个资源，做 V 操作即是释放一个用完的资源</p>\n<p>P 操作后，若 Vs &gt; 0 时，Vs 的值就是这种资源的剩余数</p>\n<p>若 Vs &lt; 0 时，表示现在已经没有资源可以分配，申请资源的进程只能被阻塞到申请队列 Vq 上去排队等待，Vs 的绝对值表示提出资源请求，但没有分配到资源的进程个数</p>\n<p>V 操作后，若 Vs &lt;= 0，表示申请资源的等待队列上有进程在等待该资源（表示 V 操作之前 Vs &lt;= -1，即至少有一个进程在队列上等待使用该资源），所以将该队列上的一个进程摘下，让它到就绪队列中排队</p>\n<p>若 Vs &gt; 0，表示 V 操作之前 Vs &gt;= 0，即资源等待队列上没有进程在等待，只是收回了一个资源</p>\n<ol>\n<li>\n<p>死锁：多个进程因竞争资源而造成的一种僵局，若无外力作用，这些进程将无法向前推进</p>\n</li>\n<li>\n<p>定义：即指系统中若存在一组（至少两个或以上）进程，它们中的每一个都占用了某种资源而又都在等待其中另一个所占用的资源，这种等待永远不会结束，这就是死锁</p>\n</li>\n<li>\n<p>产生死锁的 4 个必要条件</p>\n</li>\n</ol>\n<p>a. 互斥条件：进程对所分配的资源进行排它性使用，即在一段时间内，某资源只能被一个进程占用</p>\n<p>b. 部分分配条件（占用并等待）：进程由于申请不到所需要的资源而等待时，仍然占据着已经分配到的资源</p>\n<p>c. 非剥夺条件：已经分配给进程的资源，别的进程不能强行夺取资源，只能被占用它的进程自己释放</p>\n<p>d. 循环等待条件：在多个进程之间，由于资源的占有和请求关系，从而形成了一个循环等待的态势</p>\n<ol start=\"4\">\n<li>处理死锁的方法：</li>\n</ol>\n<p>a. 预防死锁：破坏产生死锁的 4 个必要条件之一，使系统不具备产生思索的条件</p>\n<p>b. 忽略死锁：任凭死锁出现，当系统中出现死锁时，就将系统重新启动</p>\n<p>c. 避免死锁：在资源的动态分配过程中，用某种方法防止系统进入不安全状态，从而可以避免死锁</p>\n<p>d. 检测死锁并恢复：在死锁发生后，采取相应措施加以恢复。如：撤销一些进程，回收它们的资源，将它们分配给已处于阻塞状态的进程，使其继续执行</p>\n<ol start=\"5\">\n<li>预防死锁：</li>\n</ol>\n<p>a. 互斥条件是非共享设备所必须的，不仅不能改变，还应加以保证</p>\n<p>b. 破坏占用并等待条件：所有进程在开始运行之前，必须一次性地申请其在整个过程中所需要的全部资源，一次性分配</p>\n<p>c. 破坏 “分剥夺条件”：当进程提出新的资源请求得不到满足时，它必须释放已经保持的所有资源，待以后需要时再重新申请</p>\n<p>d. 破坏循环等待条件：将系统中的所有资源进行统一编号，进程按编号的顺序，由小到大提出对资源使用的申请</p>\n<ol start=\"6\">\n<li>在信号量上的 P、V 操作，可以看作是进程间的一种通信方式，这种通信并不在进程间真正交换信息，而只是双方事先的一种约定。因此，用 P、V 操作实现的通信，称为进程间的一种低级通信</li>\n</ol>\n<p>为了使进程间能够真正交换数据，操作系统备有高级通信命令，提供给用户在程序一级使用</p>\n<p>高级进程通信分为直接通信和间接通信两种方式</p>\n<p>间接通信是指通过信箱来传递消息</p>\n",
            "tags": [
                "期末复习"
            ]
        }
    ]
}