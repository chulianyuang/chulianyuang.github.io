{
    "version": "https://jsonfeed.org/version/1",
    "title": "welcome to my world • All posts by \"数据结构与算法\" category",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2023/05/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%A0%E9%A2%98%E6%B1%87%E6%80%BB/",
            "url": "http://example.com/2023/05/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%A0%E9%A2%98%E6%B1%87%E6%80%BB/",
            "title": "数据结构与算法知识点汇总",
            "date_published": "2023-05-23T05:00:35.000Z",
            "content_html": "<h1 id=\"第一章-数据结构概述\"><a href=\"#第一章-数据结构概述\" class=\"headerlink\" title=\"第一章 数据结构概述\"></a>第一章 数据结构概述</h1><p>基本概念与术语</p>\n<ol>\n<li><p>数据：数据是对客观事物的符号表示，在计算机科学中是指所有能输入到计算机中并被<br> 计算机程序所处理的符号的总称。</p>\n</li>\n<li><p>数据元素：数据元素是数据的基本单位，是数据这个集合中的个体，也称之为元素，结点，顶点记录。<br> （补充：一个数据元素可由若干个 数据项组成。数据项是数据的不可分割的最小单位。）</p>\n</li>\n<li><p>数据对象：数据对象是具有相同性质的数据元素的集合，是数据的一个子集。（有时候也<br> 叫做属性。  </p>\n</li>\n<li><p>数据结构：数据结构是相互之间存在一种或多种特定关系的数据元素的集合。<br>（1）数据的逻辑结构是指数据元素之间存在的固有逻辑关系，常称为数<br>据结构。<br>（2）数据的逻辑结构是从数据元素之间存在的逻辑关系上描述数据与数据的存储无关，是<br>独立于计算机的。<br>依据数据元素之间的关系，可以把数据的逻辑结构分成以下几种：</p>\n</li>\n</ol>\n<p>集合：数据中的数据元素之间除了“同属于一个集合“的关系以外，没有其他关系。<br>线性结构：结构中的数据元素之间存在“一对一“的关系。若结构为非空集合，则除了第<br>一个元素之外，和最后一个元素之外，其他每个元素都只有一个直接前驱和一个直接后继。<br>树形结构：结构中的数据元素之间存在“一对多“的关系。若数据为非空集，则除了第一<br>个元素（根）之外，其它 每个数据元素都只有一个直接前驱，以及多个或零个 直<br>接后继。<br>图状结构：</p>\n<p>（1）结构中的数据元素存在“多对多”的关系。若结构为非空集，折每个数据可有<br>多个（或零个）直接后继。<br>（2）数据的存储结构：数据元素及其关系在计算机内的表示称为数据的存储结构。<br>想要计算机处理数据，就必须把数据的逻辑结构映射为数据的存储结构。<br>逻辑结构可以映射为以下两种存储结构：<br>顺序存储结构：把逻辑上相邻的数据元素存储在物理位置也相邻的存储单元中，借助元素<br>在存储器中的相对位置来表示数据之间的逻辑关系。<br>链式存储结构：借助指针表达数据元素之间的逻辑关系。不要求逻辑上相邻的数据元素物<br>理位置上也相邻。<br>时间复杂度分析：<br>1.常量阶：算法的时间复杂度与问题规模 n 无关系 T(n)&#x3D;O(1)<br>2.线性阶：算法的时间复杂度与问题规模 n 成线性关系 T(n)&#x3D;O(n)<br>3.平方阶和立方阶：一般为 循环的嵌套，循环体最后条件为 i++<br>时间复杂度的大小比较：<br>O(1)&lt; O(log 2 n)&lt; O(n )&lt; O(n log 2 n)&lt; O(n2)&lt; O(n3)&lt; O(2 n )&lt;O(n!)&lt;O(n n)<br>6.算法与程序：<br>（1）算法的 5 个特性<br>1、 输入：有零个或多个输入<br>2、 输出：有一个或多个输出<br>3、有穷性：要求序列中的指令是有限的；每条指令的执行包含有限的工作量；整个指令序<br>列的执行在有限的时间内结束。（程序与算法的区别在于，程序不需要有有穷性）<br>4、确定性：算法中的每一个步骤都必须是确定的，而不应当含糊、模棱两可。没有歧义。<br>5、可行性：算法中的每一个步骤都应当能被有效的执行，并得到确定的结果。<br>（2）.算法设计的要求：<br>1、正确性（达到预期效果，满足问题需求）<br>2、健壮性（能处理合法数据，也能对不合法的数据作出反应，不会产生不<br>可预期的后果）<br>3、可读性（要求算法易于理解，便于分析）<br>4、可修改可扩展性<br>5、高效率（较好的时空性能 ）<br>补充内容：<br>1、名词解释：数据结构、二元组<br>数据结构就是相互之间存在一种或多种特定关系的数据元素的集合。<br>二元组就是一种用来表示某个数据对象以及各个元素之间关系的有限集合。<br>2、根据数据元素之间关系的不同，数据的逻辑结构可以分为集合、线性结构、树形结构和<br>图状结构四种类型。<br>3、常见的数据存储结构一般有两种类型，它们分别是顺序存储结构、链式存储结构<br>6.在一般情况下，一个算法的时间复杂度是问题规模的函数<br>7.常见时间复杂度有：常数阶 O（1）、线性阶 O（n）、对数阶 O（log 2 n）、平方阶 O(n^2)、<br>指数阶 O(2^n)。通常认为，具有常数阶量级的算法是好算法，而具有指数阶量级的算法是<br>差算法。</p>\n<h1 id=\"第二章-线性表\"><a href=\"#第二章-线性表\" class=\"headerlink\" title=\"第二章 线性表\"></a>第二章 线性表</h1><p>定义： 线性表是 n 个数据元素的有限序列。 一个数据元素可由若干个 数据项组成。</p>\n<p>顺序表结构<br>线性表的顺序存储是指在内存中 用地址连续的一块存储空间顺序存放线性表的各元素，用这<br>种存储形式存储的线性表称为顺序表。<br>单链表<br>（1） 链表结点结构<br>线性表中的数据元素可以 用任意的一组存储单元来存储，用指针表示逻辑关系逻辑相邻的两<br>元素的存储空间可以是不连续的。<br>（2） 链表操作算法：初始化、插入、输出、删除、遍历<br><strong>初始化：p&#x3D;(struct student <em>)malloc(sizeof(struct student));<br>插入： p-&gt;next&#x3D;head-&gt;next; head-&gt;next&#x3D;p;<br>输出：printf(“%d”,p-&gt;data);<br>删除：q&#x3D;p-&gt;next; p-&gt;next &#x3D; q-&gt;next ; free(q);<br>结点遍历： for(p&#x3D;head;p;p&#x3D;p-&gt;next);</em></strong><br>补充内容：<br>1、线性表中，第一个元素没有直接前驱，最后一个元素没有直接后驱。<br>2、在一个单链表中，若 p 所指结点是 q 所指结点的前驱结点，则删除结点 q 的操作语句为<br>P-&gt;next &#x3D; q-&gt;next ; free(q);<br>3、在长度为 N 的顺序表中，插入一个新元素平均需要移动表中 N&#x2F;2 个元素，删除一个元素<br>平均需要移动（N-1）&#x2F;2 个元素。<br>4、若线性表的主要操作是在最后一个元素之后插入一个元素或删除最后一个元素，则采用<br>顺序表存储结构最节省运算时间。<br>5、已知顺序表中每个元素占用 3 个存储单元，第 13 个元素的存储地址为 336，则顺序表的<br>首地址为 300。（第 n 个元素的地址即首地址+(n-1)每个元素的存储空间，如 a[12]（第 13<br>个元素）的地址&#x3D;a[0]+123）<br>6、设有一带头结点单链表 L，请编写该单链表的初始化，插入、输出和删除函数。（函数名<br>自定义）<br>结点定义：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">int</span> datatype; <span class=\"comment\">//结点数据类型，假设为 int</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span> &#123;</span> <span class=\"comment\">//结点结构</span></span><br><span class=\"line\">datatype data;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span> *<span class=\"title\">next</span>;</span> <span class=\"comment\">//双向链表还应加上*previous</span></span><br><span class=\"line\">&#125; Lnode, * pointer ; <span class=\"comment\">//结点类型,结点指针类型</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> pointer lklist; <span class=\"comment\">//单链表类型，即头指针类型</span></span><br><span class=\"line\"><span class=\"comment\">//1.初始化：</span></span><br><span class=\"line\">lklist <span class=\"title function_\">initlist</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">pointer head;</span><br><span class=\"line\">head=new node;<span class=\"comment\">//这是 C++做法</span></span><br><span class=\"line\"><span class=\"comment\">//head=( pointer)malloc(sizeof(Lnode)); 这是 C 语言做法</span></span><br><span class=\"line\">head-&gt;next=<span class=\"literal\">NULL</span>; <span class=\"comment\">//循环链表则是 head-&gt;next=head;</span></span><br><span class=\"line\"><span class=\"comment\">//双向链表应加上 head-&gt;previos=NULL;</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> head;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//2.插入：（C 语言中需要把 head 转化为全局变量才能实现此程序）</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">insert</span><span class=\"params\">(lklist head,datatype x,<span class=\"type\">int</span> i)</span>&#123;</span><br><span class=\"line\">pointer q,s;</span><br><span class=\"line\">q=get(head,i<span class=\"number\">-1</span>); <span class=\"comment\">//找第 i-1 个点</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(q==<span class=\"literal\">NULL</span>) <span class=\"comment\">//无第 i-1 点，即 i&lt;1 或 i&gt;n+1 时</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"built_in\">cout</span>&lt;&lt;”非法插入位置!\\n”; <span class=\"comment\">//这是 C++做法，即 C 语言中的 printf(“非法插入位置!\\n”);</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">s=new node;<span class=\"comment\">//生成新结点 即 C 语言中的 s=( pointer)malloc(sizeof(Lnode));</span></span><br><span class=\"line\">s-&gt;data=x;</span><br><span class=\"line\">s-&gt;next=q-&gt;next; <span class=\"comment\">//新点的后继是原第 i 个点</span></span><br><span class=\"line\">q-&gt;next=s; <span class=\"comment\">//原第 i-1 个点的后继是新点</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">1</span>; <span class=\"comment\">//插入成功</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//3.删除：（C 语言中需要把 head 转化为全局变量才能实现此程序）</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">delete</span><span class=\"params\">(lklist head,<span class=\"type\">int</span> i)</span> &#123;</span><br><span class=\"line\">pointer p,q;</span><br><span class=\"line\">q=get(head,i<span class=\"number\">-1</span>); <span class=\"comment\">//找待删点的直接前趋</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(q==<span class=\"literal\">NULL</span> || q-&gt;next==<span class=\"literal\">NULL</span>) <span class=\"comment\">//即 i&lt;1 或 i&gt;n 时</span></span><br><span class=\"line\">&#123;<span class=\"built_in\">cout</span>&lt;&lt;”非法删除位置!\\n”;<span class=\"keyword\">return</span> <span class=\"number\">0</span>;&#125;</span><br><span class=\"line\">p=q-&gt;next; <span class=\"comment\">//保存待删点地址</span></span><br><span class=\"line\">q-&gt;next=p-&gt;next; <span class=\"comment\">//修改前趋的后继指针</span></span><br><span class=\"line\">delete p; <span class=\"comment\">//释放结点 即 C 语言中的 free(p);</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">1</span>; <span class=\"comment\">//删除成功</span></span><br></pre></td></tr></table></figure>\n\n<p>不带头结点的单链表 head 为空的判定条件是(A )<br>A. head&#x3D;NULL B. head-&gt;next&#x3D;NULL C. head-&gt;next&#x3D;head D. head!&#x3D;NULL<br>带头结点的单链表 head 为空的判定条件是(B )<br>A. head&#x3D;NULL B. head-&gt;next&#x3D;NULL C. head-&gt;next&#x3D;head D. head!&#x3D;NULL<br>在一个单链表中，若 p 所指结点不是最后结点，在 p 之后插入 s 所指结点，则执行(B )<br>A. s-&gt;next&#x3D;p; p-&gt;next&#x3D;s; B. s-&gt;next&#x3D;p-&gt;next; p-&gt;next&#x3D;s;<br>C. s-&gt;next&#x3D;p-&gt;next; p&#x3D;s; D. p-&gt;next&#x3D;s; s-&gt;next&#x3D;p;<br>在一个单链表中，若删除 p 所指结点的后续结点，则执行(A )<br>A. p-&gt;next&#x3D;p-&gt;next-&gt;next;<br>B. p&#x3D;p-&gt;next; p-&gt;next&#x3D;p-&gt;next-&gt;next;<br>C. p-&gt;next&#x3D;p-&gt;next<br>D. p&#x3D;p-&gt;next-&gt;next<br>从一个具有 n 个结点的有序单链表中查找其值等于 x 结点时，在查找成功的情况下，需平均比较（B ）个结点。<br>A. n B. (n+1)&#x2F;2 C. (n-1)&#x2F;2 D. O(n ㏒ 2n)<br>给定有 n 个元素的向量，建立一个有序单链表的时间复杂度（B）<br>A.O(1) B.O(n) C.O(n2) D.O(n ㏒ 2n)<br>在一个具有 n 个结点的有序单链表中插入一个新结点并仍然有序的时间复杂度是(B)<br>A.O(1) B.O(n) C.O(n2) D.O(n ㏒ 2n)<br>在一个单链表中删除 q 所指结点时，应执行如下操作：<br>q&#x3D;p-&gt;next;<br>p-&gt;next&#x3D;( p-&gt;next-&gt;next );<br>free(q);&#x2F;&#x2F;这种题目靠一根指针是没有办法完成的，必须要借助第二根指针。<br>在一个单链表中 p 所指结点之后插入一个 s 所指结点时，应执行：<br>s-&gt;next&#x3D;( p-&gt;next )<br>p-&gt;next&#x3D;(s)操作。<br>对于一个具有 n 个节点的单链表 ,在已知所指结点后插入一个新结点的时间复杂度是(O<br>（1）)；在给定值为 x 的结点后插入一个新结点的时间复杂度是（O(n)）。<br>11.问答题<br>线性表可用顺序表或链表存储。试问：<br>(1) 两种存储表示各有哪些主要优缺点?<br>顺序表的存储效率高，存取速度快。但它的空间大小一经定义，在程序整个运行期间不会发<br>生改变，因此，不易扩充。同时，由于在插入或删除时，为保持原有次序，平均需要移动一<br>半(或近一半)元素，修改效率不高。<br>链接存储表示的存储空间一般在程序的运行过程中动态分配和释放，且只要存储器中还有空<br>间，就不会产生存储溢出的问题。同时在插入和删除时不需要保持数据元素原来的物理顺序，<br>只需要保持原来的逻辑顺序，因此不必移动数据，只需修改它们的链接指针，修改效率较高。<br>但存取表中的数据元素时，只能循链顺序访问，因此存取效率不高。<br>(2) 若表的总数基本稳定，且很少进行插入和删除，但要求以最快的速度存取表中的元素，<br>这时，应采用哪种存储表示？为什么？<br>应采用顺序存储表示。因为顺序存储表示的存取速度快，但修改效率低。若表的总数基本稳<br>定，且很少进行插入和删除，但要求以最快的速度存取表中的元素，这时采用顺序存储表示<br>较好。</p>\n<h1 id=\"第三章-栈和队列\"><a href=\"#第三章-栈和队列\" class=\"headerlink\" title=\"第三章 栈和队列\"></a>第三章 栈和队列</h1><ol>\n<li>栈<br>（1） 栈的结构与定义<br>定义：限定仅在表尾进行插入或删除操作的线性表。<br>结构：<br>typedef struct list{<br>int listsize; &#x2F;&#x2F;栈的容量<br>struct list *head; &#x2F;&#x2F;栈顶指针<br>struct list *base; &#x2F;&#x2F;栈底指针<br>}</li>\n</ol>\n<p>（2） 顺序栈操作算法：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 初始化栈</span></span><br><span class=\"line\">Status <span class=\"title function_\">InitStack</span><span class=\"params\">(SqStack *S)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 分配初始空间</span></span><br><span class=\"line\">    S-&gt;base = (ElemType *) <span class=\"built_in\">malloc</span>(Stack_Init_Size * <span class=\"keyword\">sizeof</span>(ElemType));</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!S-&gt;base) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    S-&gt;top = S-&gt;base; <span class=\"comment\">/// 栈顶与栈底相同</span></span><br><span class=\"line\">    S-&gt;stack_size = Stack_Init_Size; <span class=\"comment\">// 栈的最大长度等于初始长度</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 判断栈是否为空，只需要判断栈顶指针与栈底指针是否相同即可</span></span><br><span class=\"line\">Status <span class=\"title function_\">EmptyStack</span><span class=\"params\">(SqStack *S)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> S-&gt;base == S-&gt;top;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取栈的实际长度，栈顶减去栈底指针即为栈的长度</span></span><br><span class=\"line\">Status <span class=\"title function_\">LengthStack</span><span class=\"params\">(SqStack *S)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (S-&gt;top == S-&gt;base) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (Status) (S-&gt;top - S-&gt;base);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取栈顶的元素，参数e用来存放栈顶的元素</span></span><br><span class=\"line\">Status <span class=\"title function_\">GetTopStack</span><span class=\"params\">(SqStack *S, ElemType *e)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (S-&gt;top == S-&gt;base) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    *e = *(S-&gt;top - <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 进栈，参数e是要进栈的元素</span></span><br><span class=\"line\">Status <span class=\"title function_\">PushStack</span><span class=\"params\">(SqStack *S, ElemType e)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 若栈的最大长度不会够用时，重新开辟，增大长度</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (S-&gt;top - S-&gt;base &gt;= S-&gt;stack_size) &#123;</span><br><span class=\"line\">        S-&gt;base = (ElemType *)<span class=\"built_in\">realloc</span>(S-&gt;base, (S-&gt;stack_size + StackIncrement) * <span class=\"keyword\">sizeof</span>(ElemType));</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!S-&gt;base) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 栈顶指针为栈底指针加上栈之前的最大长度</span></span><br><span class=\"line\">        S-&gt;top = S-&gt;base + S-&gt;stack_size;</span><br><span class=\"line\">        <span class=\"comment\">// 栈当前的最大长度等于栈之前的最大长度与增加的长度之和</span></span><br><span class=\"line\">        S-&gt;stack_size += StackIncrement;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    *S-&gt;top++ = e; <span class=\"comment\">// 先赋值，后栈顶指针上移</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 出栈，参数e用来存放出栈的元素</span></span><br><span class=\"line\">Status <span class=\"title function_\">PopStack</span><span class=\"params\">(SqStack *S, ElemType *e)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (S-&gt;base == S-&gt;top) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    *e = *--S-&gt;top; <span class=\"comment\">// 栈顶指针先下移，后赋值</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 销毁栈，释放栈空间，栈顶栈底指针置为NULL，长度置为0</span></span><br><span class=\"line\">Status <span class=\"title function_\">DestroyStack</span><span class=\"params\">(SqStack *S)</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(S-&gt;base);</span><br><span class=\"line\">    S-&gt;base = S-&gt;top = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">    S-&gt;stack_size = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 遍历栈，依次打印每个元素</span></span><br><span class=\"line\">Status <span class=\"title function_\">StackTraverse</span><span class=\"params\">(SqStack *S)</span> &#123;</span><br><span class=\"line\">    ElemType *p;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (S-&gt;top == S-&gt;base) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Stack is NULL.\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    p = S-&gt;top;</span><br><span class=\"line\">    <span class=\"comment\">// 由栈顶依次向下遍历</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (p &gt; S-&gt;base) &#123;</span><br><span class=\"line\">        p--;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>, *p);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>（3） 链栈操作算法<br>结构：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">StackNode</span>&#123;</span></span><br><span class=\"line\">\t ElemType data;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">StackNode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125;StackNode, *LinkStack;</span><br></pre></td></tr></table></figure>\n\n\n<p>初始化：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Status <span class=\"title function_\">InitStack</span><span class=\"params\">(LinkStack &amp;S)</span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//构造一个空栈，栈顶指针置为空 </span></span><br><span class=\"line\">\tS = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>入栈：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Status <span class=\"title function_\">Push</span><span class=\"params\">(LinkStack &amp;S,ElemType e)</span>&#123;</span><br><span class=\"line\">\t    LinkStack p;<span class=\"comment\">//定义p </span></span><br><span class=\"line\">\t\tp=new StackNode;<span class=\"comment\">//生成新结点 </span></span><br><span class=\"line\">\t\tp-&gt;data=e;<span class=\"comment\">//e赋给新结点的数据域 </span></span><br><span class=\"line\">\t\tp-&gt;next=S; <span class=\"comment\">//新结点插入栈顶 </span></span><br><span class=\"line\">\t\tS=p;<span class=\"comment\">//修改栈顶指针为p</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>出栈：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Status <span class=\"title function_\">Pop</span><span class=\"params\">(LinkStack &amp;S,ElemType &amp;e)</span>&#123;</span><br><span class=\"line\">\tLinkStack p;<span class=\"comment\">//定义p </span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(S==<span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> ERROR;<span class=\"comment\">//栈空 </span></span><br><span class=\"line\">\te=S-&gt;data;<span class=\"comment\">//将栈顶元素赋给e </span></span><br><span class=\"line\">\tp=S;<span class=\"comment\">//p临时保存栈顶元素以备释放 </span></span><br><span class=\"line\">\tS=S-&gt;next;<span class=\"comment\">//修改栈顶指针 </span></span><br><span class=\"line\">\tdelete p;<span class=\"comment\">//释放空间 </span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<ol start=\"2\">\n<li>队列<br>（1） 队列的定义<br>定义：只允许在表的一端进行插入，而在另一端删除元素。</li>\n</ol>\n<p>补充内容：<br>1、一个栈的入栈序列为“ABCDE”，则以下不可能的出栈序列是（B）<br>A. BCDAE B. EDACB C. BCADE D. AEDCB<br>2、栈的顺序表示中，用 TOP 表示栈顶元素，那么栈空的条件是（D）<br>A. TOPSTACKSIZE B. TOP1 C. TOP0 D. TOP-1<br>3、允许在一端插入，在另一端删除的线性表称为队列。插入的一端为表头，删除的一端为<br>表尾。<br>4、栈的特点是先进后出，队列的特点是先进先出。<br>5、对于栈和队列，无论他们采用顺序存储结构还是链式存储结构，进行插入和删除操作的<br>时间复杂度都是 O(1)（即与已有元素 N 无关）。<br>6、已知链栈 Q，编写函数判断栈空，如果栈空则进行入栈操作，否则出栈并输出。（要求判<br>断栈空、出栈、入栈用函数实现）（详看考点 2）<br>7.出队与取队头元素的区别：出队就是删除对头的数据元素，取队头元素是获取对头的数据<br>元素值，不需要删除。<br>8.链栈与顺序栈相比，比较明显的优点是：（D）<br>A.插入操作比较容易 B.删除操作比较容易<br>C.不会出现栈空的情况 D.不会出现栈满的情况</p>\n<p>考点 1：队列的编程：<br>结构：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">QNode</span>&#123;</span></span><br><span class=\"line\"><span class=\"type\">int</span> date;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">QNode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125;QNode,*QueuePtr;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">QueuePtr front;</span><br><span class=\"line\">QueuePtr rear;</span><br><span class=\"line\">&#125;LinkQueue;</span><br></pre></td></tr></table></figure>\n\n<p>创建：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LinkQueue <span class=\"title function_\">InitQueue</span><span class=\"params\">(LinkQueue Q)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">Q.front=Q.rear=(QueuePtr)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(QNode));</span><br><span class=\"line\">Q.front-&gt;next=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\"><span class=\"keyword\">return</span> (Q);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>入队：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LinkQueue <span class=\"title function_\">EnQueue</span><span class=\"params\">(LinkQueue Q,<span class=\"type\">int</span> e)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">QueuePtr p;</span><br><span class=\"line\">p=(QueuePtr)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(QNode));</span><br><span class=\"line\">p-&gt;date=e;</span><br><span class=\"line\">p-&gt;next=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">Q.rear-&gt;next=p;</span><br><span class=\"line\">Q.rear=p;</span><br><span class=\"line\"><span class=\"keyword\">return</span> (Q);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n<p>出队：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LinkQueue <span class=\"title function_\">DeQueue</span><span class=\"params\">(LinkQueue Q)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"type\">int</span> e;</span><br><span class=\"line\">QueuePtr p;</span><br><span class=\"line\">p=Q.front-&gt;next;</span><br><span class=\"line\">e=p-&gt;date;</span><br><span class=\"line\">Q.front=p-&gt;next;</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d&quot;</span>,e);</span><br><span class=\"line\"><span class=\"keyword\">if</span>(Q.rear==p)Q.rear=Q.front=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\"><span class=\"built_in\">free</span>(p);</span><br><span class=\"line\"><span class=\"keyword\">return</span> (Q);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"第四章-串\"><a href=\"#第四章-串\" class=\"headerlink\" title=\"第四章 串\"></a>第四章 串</h1><p>1.串是由零个或多个字符组成的有限序列<br>2.串的赋值：x&#x3D;’abc’;或 x[ ]&#x3D;’abc’;</p>\n<p>第五章 数组和广义表 （不是重点内容）<br>多维数组中某数组元素的 position 求解。一般是给出数组元素的首元素地址和每个元素占<br>用的地址空间并组给出多维数组的维数，然后要求你求出该数组中的某个元素所在的位置。<br>明确 按行存储和 按列存储的区别和联系，并能够按照这两种不同的存储方式求解 1 中类<br>型的题。<br>将特殊矩阵中的元素按相应的换算方式存入数组中。这些矩阵包括：对称矩阵，三角矩<br>阵，具有某种特点的稀疏矩阵等。熟悉稀疏矩阵的三种不同存储方式： 三元组，带辅助行向<br>量的二元组， 十字链表存储。掌握将稀疏矩阵的三元组或二元组向十字链表进行转换的算法。<br>补充内容：<br>三元组：<br>结构：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\"><span class=\"type\">int</span> i,j; <span class=\"comment\">//元素行下标及列下标</span></span><br><span class=\"line\"><span class=\"type\">int</span> e; <span class=\"comment\">//元素值</span></span><br><span class=\"line\">&#125;Triple;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\"><span class=\"type\">int</span> mu,nu,tu; <span class=\"comment\">//矩阵的行数、列数、非零元素个数</span></span><br><span class=\"line\">Triple data[MAXSIZE+<span class=\"number\">1</span>]; <span class=\"comment\">//矩阵包含的三元组表，data[0]未用</span></span><br><span class=\"line\">&#125;TSMatrix;</span><br></pre></td></tr></table></figure>\n\n\n<p>十字链表：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">OLNode</span>&#123;</span></span><br><span class=\"line\"><span class=\"type\">int</span> i,j; <span class=\"comment\">//元素行下标及列下标</span></span><br><span class=\"line\"><span class=\"type\">int</span> e; <span class=\"comment\">//元素值</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">OLNode</span> *<span class=\"title\">right</span>,*<span class=\"title\">down</span>;</span> <span class=\"comment\">//行的后继以及列的后继</span></span><br><span class=\"line\">&#125; OLNode，*OLink;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\"><span class=\"type\">int</span> mu,nu,tu; <span class=\"comment\">//矩阵的行数、列数、非零元素个数</span></span><br><span class=\"line\">OLink *rhead,*chead; <span class=\"comment\">//行和列的表头指针组的首地址</span></span><br><span class=\"line\">&#125;CrossList;</span><br><span class=\"line\"></span><br><span class=\"line\">CrossList Creat（CrossList M）&#123;</span><br><span class=\"line\"><span class=\"type\">int</span> m,n,t;</span><br><span class=\"line\"><span class=\"built_in\">scanf</span>(“%d%d%d”,&amp;m,&amp;n,&amp;t);</span><br><span class=\"line\">M.mu=m;M.nu=n;M.tu=t;</span><br><span class=\"line\">M.rhead=( OLink *)<span class=\"built_in\">malloc</span>((m+<span class=\"number\">1</span>)*<span class=\"keyword\">sizeof</span>(OLink)); <span class=\"comment\">//开辟行表头指针组</span></span><br><span class=\"line\">M.chead=( OLink *)<span class=\"built_in\">malloc</span>((n+<span class=\"number\">1</span>)*<span class=\"keyword\">sizeof</span>(OLink)); <span class=\"comment\">//开辟行列头指针组</span></span><br><span class=\"line\">M.rhead[]=M.chead[]=<span class=\"literal\">NULL</span>; <span class=\"comment\">//初始化</span></span><br><span class=\"line\">…… <span class=\"comment\">//接下来就是赋值和入链</span></span><br><span class=\"line\">｝</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"第六章-树和二叉树\"><a href=\"#第六章-树和二叉树\" class=\"headerlink\" title=\"第六章 树和二叉树\"></a>第六章 树和二叉树</h1><h2 id=\"1．-树\"><a href=\"#1．-树\" class=\"headerlink\" title=\"1． 树\"></a>1． 树</h2><p>（1） 树的概念及术语<br>树 ：n（n≥0）个结点的有限集合。当 n＝0 时，称为空树；任意一棵非空树满足以下条件：<br>⑴ 有且仅有一个特定的称为根的结点；<br>⑵ 当 n＞1 时，除根结点之外的其余结点被分成 m（m&gt;0）个互不相交的有限集合<br>T1,T2,… ,Tm，其中每个集合又是一棵树，并称为这个根结点的子树。<br>（2） 结点的度： 结点所拥有的子树的个数。<br>树的度：树中所有结点的度的最大值。<br>（3） 叶子结点： 度为 0 的结点，也称为终端结点。<br>分支结点：度不为 0 的结点，也称为非终端结点。<br>（4）孩子、双亲 ：树中某结点的子树的根结点称为这个结点的孩子结点，这个结点称为它<br>孩子结点的双亲结点；<br>兄弟： 具有同一个双亲的孩子结点互称为兄弟。<br>（5）路径： 如果树的结点序列 n1, n2, …, nk 有如下关系：结点 ni 是 ni+1 的双亲（1&lt;&#x3D;i&lt;k），<br>则把 n1, n2, …, nk 称为一条由 n1 至 nk 的路径；路径上经过的边的个数称为路径长度。<br>（6）祖先、子孙： 在树中，如果有一条路径从结点 x 到结点 y，那么 x 就称为 y 的祖先，<br>而 y 称为 x 的子孙。<br>（7）结点所在层数： 根结点的层数为 1；对其余任何结点，若某结点在第 k 层，则其孩子<br>结点在第 k+1 层。<br>树的深度： 树中所有结点的最大层数，也称高度。<br>（8）层序编号： 将树中结点按照从上层到下层、同层从左到右的次序依次给他们编以从 1<br>开始的连续自然数。<br>（9）有序树、无序树： 如果一棵树中结点的各子树从左到右是有次序的，称这棵树为有序<br>树；反之，称为无序树。数据结构中讨论的一般都是有序树<br>（10） 树通常有前序（根）遍历、后序（根）遍历和层序（次）遍历三种方式（树，<br>不是二叉树，没中序遍历。)</p>\n<h2 id=\"2．-二叉树\"><a href=\"#2．-二叉树\" class=\"headerlink\" title=\"2． 二叉树\"></a>2． 二叉树</h2><p>（1）二叉树的定义：二叉树是 n（n≥0）个结点的有限集合，该集合或者为空集（称为空<br>二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉<br>树组成。</p>\n<p>满二叉树：在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在<br>同一层上。<br>（满二叉树的特点：叶子只能出现在最下一层；只有度为 0 和度为 2 的结点。）<br>完全二叉树：对一棵具有 n 个结点的二叉树按层序编号，如果编号为 i（1≤i≤n）的结点与<br>同样深度的满二叉树中编号为 i 的结点在二叉树中的位置完全相同。<br>完全二叉树的特点：<br>1.在满二叉树中，从最后一个结点开始，连续去掉任意个结点，即是一棵完全二叉树。<br>2.叶子结点只能出现在最下两层，且最下层的叶子结点都集中在二叉树的左部；</p>\n<p>3.完全二叉树中如果有度为 1 的结点，只可能有一个，且该结点只有左孩子。</p>\n<p>4.深度为 k 的完全二叉树在 k-1 层上一定是满二叉树。</p>\n<p>（2）二叉树的性质：<br>性质 1：二叉树的第 i 层上最多有 2i-1 个结点（i≥1）。<br>性质 2： 一棵深度为 k 的二叉树中，最多有 2k-1 个结点，最少有 k 个结点。深度为 k<br>且具有 2k-1 个结点的二叉树一定是满二叉树<br>性质 3：在一棵二叉树中，如果叶子结点数为 n0，度为 2 的结点数为 n2，则有: n0＝n2<br>＋1。（一个结点的度就是指它放出的射线）<br>性质 4：具有 n 个结点的完全二叉树的深度为 log2n +1。<br>性质 5： 对一棵具有 n 个结点的完全二叉树中从 1 开始按层序编号，则对于任意的序<br>号为 i（1≤i≤n）的结点（简称为结点 i），有：<br>（1）如果 i＞1，则结点 i 的双亲结点的序号为 i&#x2F;2；如果 i＝1，则结点 i 是根结点，无双<br>亲结点。<br>（2）如果 2i≤n，则结点 i 的左孩子的序号为 2i；如果 2i＞n，则结点 i 无左孩子。<br>（3）如果 2i＋1≤n，则结点 i 的右孩子的序号为 2i＋1；如果 2i＋1＞n，则结点 i 无右孩子。</p>\n<h2 id=\"3．-二叉树的遍历（递归调用与访问的顺序不同而产生不同的遍历方法）\"><a href=\"#3．-二叉树的遍历（递归调用与访问的顺序不同而产生不同的遍历方法）\" class=\"headerlink\" title=\"3． 二叉树的遍历（递归调用与访问的顺序不同而产生不同的遍历方法）\"></a>3． 二叉树的遍历（递归调用与访问的顺序不同而产生不同的遍历方法）</h2><p>（1） 先序遍历</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">XianXu</span><span class=\"params\">(BiTree T)</span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(T)&#123;</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%c&quot;</span>,T-&gt;data); <span class=\"comment\">//先访问</span></span><br><span class=\"line\">XianXu(T-&gt;lchild); <span class=\"comment\">//再继续遍历</span></span><br><span class=\"line\">XianXu(T-&gt;rchild);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>（2） 中序遍历<br>（3） 后序遍历</p>\n<h2 id=\"4-森林与二叉树的转换\"><a href=\"#4-森林与二叉树的转换\" class=\"headerlink\" title=\"4. 森林与二叉树的转换\"></a>4. 森林与二叉树的转换</h2><p>（1）同级以左为亲，即左一结点的右孩子是与它同级的右一结点<br>（2）只认最左路线为亲子路线，即结点的左孩子是它下一级结点的最左的元素</p>\n<h2 id=\"5-哈夫曼树\"><a href=\"#5-哈夫曼树\" class=\"headerlink\" title=\"5. 哈夫曼树\"></a>5. 哈夫曼树</h2><p>(1）哈夫曼树的基本概念：<br>哈夫曼树：给定一组具有确定权值的叶子结点， 带权路径长度最小的二叉树。<br>(2）哈夫曼树的特点：</p>\n<p>权值越大的叶子结点越靠近根结点，而权值越小的叶子结点越远离根结点。<br>只有度为 0（叶子结点）和度为 2（分支结点）的结点，不存在度为 1 的结点.<br>（3）哈夫曼树的构造算法思想及构造过程（森林与 哈夫曼编码）<br>就是求各权值和路径相乘之后叠加的最小值。</p>\n<p>1、已知一棵完全二叉树有 47 个结点，则该二叉树有（C）个叶子结点。<br>A. 6 B. 12 C. 24 D.48<br>解法如下：<br>1+2+4+8+16&#x3D;31 计算从第一层到 n-1 层的结点个数<br>47-31&#x3D;16 计算第 n 层的叶子结点个数<br>16-16&#x2F;2&#x3D;8 计算第 n-1 层的叶子结点个数<br>所以，叶子结点数&#x3D;16+8&#x3D;24 计算第 n 层和第 n-1 层的总叶子结点数<br>2、已知遍历一棵二叉树的前序序列 ABCDEFG 和中序序列 CBEDAFG，那么是下面哪棵树<br>（C ）。<br>C 图如下：<br>　　　　　　　　　　　 A<br>　　　　　　　　　　↙　 ↘<br>　　　　　　　　　 Ｂ　　　F<br>　　　　　　　　↙ 　↘ 　　　↘<br>　　　　　　　C 　　　D 　　　　 G<br>　　　　　　　　　　↙<br>　　　　　　　　　E<br>4、完全二叉树必须满足的条件为: ：一棵具有 n 个结点的二叉树，它的结构与满二叉树的<br>前 n 个结点的的结构相同。<br>5、哈夫曼树不存在度为 1 的结点。<br>6、有 5 个带权结点，其权值分别为 2，5，3，7，11，根据哈夫曼算法构建该树，并计算该<br>树的带权路径长度。（构建哈夫曼树，很简单，从小开始，计算相加，然后把所有叶子结点<br>乘以等级数字然后相加。也即是：带权路径长度&#x3D;叶结点的权值*路径长度）<br>7.试找出分别满足下列条件的所有二叉树：<br>⑴ 前序序列和中序序列相同：只有右子树<br>⑵ 中序序列和后序序列相同：只有左子树<br>⑶ 前序序列和后序序列相同：只有根，空二叉树</p>\n<h1 id=\"第七章-图\"><a href=\"#第七章-图\" class=\"headerlink\" title=\"第七章 图\"></a>第七章 图</h1><ol>\n<li><p>图的基本概念：<br>图的结点之间的关系可以是任意的，图中任意两个数据元素之间都可能相关。<br>设图有 n 个顶点，则：<br>有 1&#x2F;2 n(n-1)条边的无向图称为 完全图<br>有 n（n-1）条弧的有向图称为 有向完全图<br>元素被多少条弧的箭头所指，它的 入度就为多少；反之，出度。<br>第一个顶点和最后一个顶点相同的路径叫做 回路或环 环<br>顶点不重复出现的路径叫 简单路径<br>若图中任意两个顶点之间存在路径（不一定是直接相连），则称作 连通图。</p>\n</li>\n<li><p>邻接矩阵：<br>．<br>　　　　　　　　　　　　　　W i,j &lt;V i ，V j &gt; ∈VR<br>　　邻接矩阵的定义： A[i][j]&#x3D;{<br>　　　　　　　　　　　　　　0 即 VR 中不存在 &lt;V i ，V j &gt;时</p>\n</li>\n<li><p>图的遍历<br>（1）深度优先遍历<br>步骤：1.从任意顶点开始访问。<br>2.访问后把该元素对应的访问标志赋值为 1 表示已访问该数据元素<br>3.寻找与其有关未被访问的所有邻接顶点，并从该顶点开始进行访问</p>\n</li>\n<li><p>重复 2、3 步骤直到该连通图的所有顶点均已访问完毕<br>（2）广度优先遍历<br>步骤：1.从任意顶点开始访问。<br>2.访问后把该元素对应的访问标志赋值为 1 表示已访问该数据元素<br>3.寻找与其有关未被访问的邻接顶点，并按顺序入列直到所有邻接顶点均<br>已访问完毕<br>4.把最先入列的顶点出列，以它为顶点开始访问</p>\n</li>\n<li><p>重复 2、3、4 步骤直到该连通图的所有顶点均已访问完毕</p>\n</li>\n</ol>\n<h1 id=\"第八九十章\"><a href=\"#第八九十章\" class=\"headerlink\" title=\"第八九十章\"></a>第八九十章</h1><p>查找表<br>是由同一类型的数据元素（或记录）构成的集合<br>对查找表的操作有：<br>（1） 查询某个“特定的”数据元素是否在查找表中；<br>（2） 检索某个“特定的”数据元素的各种属性<br>（3） 在查找表中插入一个数据元素；<br>（4） 从查找表中删去某个特定元素<br>静态查找表<br>只进行前两种“查找”操作的查找表为静态查找表<br>动态查找表<br>若在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已存在的某<br>个数据元素，则成为动态查找表<br>排序<br>其功能是将一个数据元素（或记录）的任意序列，重新排列成一个按关键字有序的序列。</p>\n",
            "tags": [
                "期末复习"
            ]
        },
        {
            "id": "http://example.com/2023/05/22/%E9%98%9F%E5%88%97/",
            "url": "http://example.com/2023/05/22/%E9%98%9F%E5%88%97/",
            "title": "队列",
            "date_published": "2023-05-22T09:30:12.000Z",
            "content_html": "<h1 id=\"2、队列\"><a href=\"#2、队列\" class=\"headerlink\" title=\"2、队列\"></a>2、队列</h1><h2 id=\"2-1-队列的基本概念\"><a href=\"#2-1-队列的基本概念\" class=\"headerlink\" title=\"2.1 队列的基本概念\"></a>2.1 队列的基本概念</h2><p>队列：队列简称队，是一种操作受限的线性表，只允许在表的一端进行插入，而在表的另一端进行删除。向队列种插入元素称为入队或进队；删除元素称为出队或离队。队列的示意图如下所示：</p>\n<p>对头（front）：允许删除的一端，又称队首。<br>队尾（rear）：允许插入的一端。<br>空队列：不含任何元素的空表。<br>队列的特性：先进先出。<br>队列的应用：速度不匹配问题、多用户资源竞争问题。</p>\n<p>注意：栈和队列都是操作受限的线性表，不是任何对线性表的操作都适合栈和队列的操作，不可以随便读取栈或队列中间的某个元素。</p>\n<h2 id=\"2-2-队列的顺序存储结构\"><a href=\"#2-2-队列的顺序存储结构\" class=\"headerlink\" title=\"2.2 队列的顺序存储结构\"></a>2.2 队列的顺序存储结构</h2><h3 id=\"1-队列的顺序存储\"><a href=\"#1-队列的顺序存储\" class=\"headerlink\" title=\"1.队列的顺序存储\"></a>1.队列的顺序存储</h3><p>队列的顺序实现是指分配一块连续的存储单元存放队列中的元素，并附设两个指针：对头指针 front 指向对头元素，队尾指针 rear 指向队尾元素的下一个位置。</p>\n<p>队列的顺序存储类型描述如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MaxSize 50  <span class=\"comment\">//定义队列中元素的最大个数</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">   ElemType data[MaxSize];  <span class=\"comment\">//存放队列元素</span></span><br><span class=\"line\">   <span class=\"type\">int</span> front,rear;  <span class=\"comment\">//队头指针和队尾指针</span></span><br><span class=\"line\">   &#125; SqQueue;</span><br></pre></td></tr></table></figure>\n\n<p>初始状态（队空条件）：Q.front &#x3D;&#x3D; Q.rear &#x3D;&#x3D; 0<br>进队操作：队不满时，先送值到队尾元素，再将队尾指针加1<br>出队操作：队不空时，先取队头元素值，再将队头指针加1</p>\n<p>队列的操作示意图如下图所示：</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/chulianyuang/imap/202305231746417.png\" alt=\"在这里插入图片描述\"></p>\n<p>队列操作示意图中 d 图所示，队列中仅有一个元素，再进行入队操作时，会出现“上溢出”，但这种溢出不是真正的溢出，在队列数组中仍然存在可以存放元素的空位置，这是一种“假溢出”。</p>\n<h3 id=\"2-循环队列\"><a href=\"#2-循环队列\" class=\"headerlink\" title=\"2.循环队列\"></a>2.循环队列</h3><p>循环队列：将顺序队列臆造成一个环状的空间，即把存储队列元素的表从逻辑上视为一个环，称为循环队列。</p>\n<p>当队首指针 Q.front &#x3D; MaxSize-1 后，再前进一个位置就会自动到 0，可利用除法取余（%）来实现。</p>\n<p>初始时：Q.front &#x3D; Q.rear &#x3D; 0<br>队首指针进1：Q.front &#x3D; (Q.front + 1)%MaxSize<br>队尾指针进1：Q.rear &#x3D; (Q.rear + 1)%MaxSize<br>队列长度：(Q.rear + MaxSize - Q.front)%MaxSize<br>出队入队时：指针都按照顺时针方向进1<br><strong>注意：不能用动态分配的一维数组来实现循环队列，初始化时必须设定一个最大队列长度。</strong></p>\n<h4 id=\"为了区分循环队列队空还是队满情况，有三种处理方式，其中第一种为常用的区分方式，重点掌握：\"><a href=\"#为了区分循环队列队空还是队满情况，有三种处理方式，其中第一种为常用的区分方式，重点掌握：\" class=\"headerlink\" title=\"为了区分循环队列队空还是队满情况，有三种处理方式，其中第一种为常用的区分方式，重点掌握：\"></a><strong>为了区分循环队列队空还是队满情况，有三种处理方式，其中第一种为常用的区分方式，重点掌握：</strong></h4><p>（1）牺牲一个单元来区分队空还是队满，入队时少用一个队列单元，约定以“队头指针在队尾的下一个指针作为堆满标志”。如下图 (d2) 所示。</p>\n<p>队满条件： (Q.rear + 1)%MaxSize &#x3D;&#x3D; Q.front<br>队空条件：Q.front &#x3D;&#x3D; Q.rear<br>队列中元素的个数：(Q.rear + MaxSize - Q.front)%MaxSize<br>（2）类型中增设表示元素个数的数据成员。对空的条件为 Q.size &#x3D; 0，队满的条件为 Q.size &#x3D;&#x3D; MaxSize，有Q.front &#x3D;&#x3D; Q.rear。<br>（3）类型中增设 tag 数据成员，以区分是队空还是队满。tag &#x3D; 0 时，若因删除导致 Q.front &#x3D;&#x3D; Q.rear，则为队空；tag &#x3D; 1 时，若因插入导致 Q.front &#x3D;&#x3D; Q.rear，则为队满。</p>\n<p>循环队列出入队示意图如下所示：</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/chulianyuang/imap/202305231746287.png\" alt=\"在这里插入图片描述\"></p>\n<p>3 . 循环队列的操作</p>\n<p>（1）初始化</p>\n   <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">InitQueue</span><span class=\"params\">(SqQueue &amp;Q)</span>&#123;</span><br><span class=\"line\">   Q.front == Q.rear=<span class=\"number\">0</span>;  <span class=\"comment\">//初始化队首、队尾指针</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>（2）判队空</p>\n<pre><code> bool isEmpty(SqQueue Q)&#123;\n    if(Q.front == Q.rear) //队空条件\n       return true;\n    else\n       return false;\n &#125;\n</code></pre>\n<p>（3）入队</p>\n<pre><code> bool EnQueue(SqQueue &amp;Q,ElemType x)&#123;\n    if( (Q.rear + 1)%MaxSize == Q.front) //队满则报错\n       return false; \n    Q.data[Q.rear]=x;\n    Q.rear= (Q.rear + 1)%MaxSize;  //队尾指针加1模\n    return true;\n &#125;   \n</code></pre>\n<p>（4）出队</p>\n<pre><code> bool DeQueue(SqQueue &amp;Q,ElemType &amp;x)&#123;\n    if(Q.front == Q.rear)  //队空则报错\n       return false;\n    x=Q.data[Q.front]; \n    Q.front = (Q.front + 1)%MaxSize;  //队头指针加1取模\n    return true;\n &#125;\n</code></pre>\n<ol start=\"4\">\n<li>顺序队列示例代码<br>顺序队列基本操作：顺序队列的初始化、入队列、出队列以及显示队列中的数据元素的示例代码如下所示：</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> QINITSIZE 100</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> QINCRECEMENT 10</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> OK 1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ERROR 0</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> null 0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">int</span> Status;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">int</span> QElemType;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">QueueType</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    QElemType *front;</span><br><span class=\"line\">    QElemType *rear;</span><br><span class=\"line\">    <span class=\"type\">int</span> qsize;</span><br><span class=\"line\">&#125;<span class=\"built_in\">queue</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">Status <span class=\"title function_\">q_init</span><span class=\"params\">(<span class=\"built_in\">queue</span> *q)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tq-&gt;front = (QElemType *)<span class=\"built_in\">malloc</span>(QINITSIZE*<span class=\"keyword\">sizeof</span>(QElemType));</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(q-&gt;front == null)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ERROR;</span><br><span class=\"line\">\tq-&gt;rear = q-&gt;front;</span><br><span class=\"line\">\tq-&gt;qsize = QINITSIZE;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Status <span class=\"title function_\">Enqueue</span><span class=\"params\">(<span class=\"built_in\">queue</span> *q,<span class=\"type\">int</span> e)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(q-&gt;rear - q-&gt;front &gt;= QINITSIZE)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tq-&gt;front = (QElemType *)<span class=\"built_in\">realloc</span>(q,(q-&gt;qsize + QINCRECEMENT)*<span class=\"keyword\">sizeof</span>(QElemType));</span><br><span class=\"line\">\t\tq-&gt;rear = q-&gt;front;</span><br><span class=\"line\">\t\tq-&gt;qsize += QINCRECEMENT; </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t*q-&gt;rear++ = e;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Status <span class=\"title function_\">Dequeue</span><span class=\"params\">(<span class=\"built_in\">queue</span> *q,<span class=\"type\">int</span> *e)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(q-&gt;rear == q-&gt;front)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ERROR;</span><br><span class=\"line\">\t*e = *q-&gt;front++;</span><br><span class=\"line\">\tq-&gt;qsize--;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">queue</span> q;</span><br><span class=\"line\">\tQElemType e,*p;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(q_init(&amp;q))</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;顺序队列创建成功!\\n&quot;</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tEnqueue(&amp;q,<span class=\"number\">1</span>);</span><br><span class=\"line\">\tEnqueue(&amp;q,<span class=\"number\">2</span>);</span><br><span class=\"line\">\tEnqueue(&amp;q,<span class=\"number\">3</span>);</span><br><span class=\"line\">\tEnqueue(&amp;q,<span class=\"number\">4</span>);</span><br><span class=\"line\">\tEnqueue(&amp;q,<span class=\"number\">5</span>);</span><br><span class=\"line\">\tp = q.front;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;顺序队列里面的数据为:\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(p &lt; q.rear)</span><br><span class=\"line\">\t    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>,*p++);</span><br><span class=\"line\">\tDequeue(&amp;q,&amp;e);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n被删除的元素:\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>,e);</span><br><span class=\"line\">\tp=q.front;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;删除队头后的数据为:\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(p&lt;q.rear)</span><br><span class=\"line\">\t     <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d &quot;</span>,*p++);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下图所示：<img data-src=\"https://cdn.jsdelivr.net/gh/chulianyuang/imap/202305231746520.png\" alt=\"在这里插入图片描述\"></p>\n<h2 id=\"2-3-队列的链式存储结构\"><a href=\"#2-3-队列的链式存储结构\" class=\"headerlink\" title=\"2.3 队列的链式存储结构\"></a>2.3 队列的链式存储结构</h2><h3 id=\"1-队列的链式存储\"><a href=\"#1-队列的链式存储\" class=\"headerlink\" title=\"1.队列的链式存储\"></a>1.队列的链式存储</h3><p>队列的链式表示称为链队列，实际上是一个同时带有队头指针和队尾指针的单链表。头指针指向队头结点，尾指针指向队尾结点，即单链表的最后一个结点。</p>\n<p>队列的不带头结点的链式存储示意图如下图所示：<img data-src=\"https://cdn.jsdelivr.net/gh/chulianyuang/imap/202305231747307.png\" alt=\"在这里插入图片描述\"></p>\n<p>队列的链式存储类型代码描述如下所示：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span>  <span class=\"comment\">//链式队列结点</span></span><br><span class=\"line\">   ElemType data;</span><br><span class=\"line\">   <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkNode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125;LinkNode;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span>  <span class=\"comment\">//链式队列</span></span><br><span class=\"line\">   LinkNode *front,*rear;  <span class=\"comment\">//队列的队头和队尾指针</span></span><br><span class=\"line\">&#125;LinkQueue;</span><br></pre></td></tr></table></figure>\n\n<p>当 Q.front &#x3D;&#x3D; NULL 且 Q.rear &#x3D;&#x3D; NULL 时，链式队列为空。</p>\n<p>出队时，首先判断队是否为空，若不空，则取出队头元素，将其从链表中移除，并让 Q.front 指向下一个结点（若该结点为最后一个结点，则令 Q.front 和 Q.rear 都为 NULL）。入队时，建立一个新结点，将新结点插入到链表的尾部，并改让 Q.rear 指向这个新插入的结点（若原队列为空队，则另 Q.front 也指向该结点）。</p>\n<p>由于不带头结点的链式队列在操作上比较麻烦，因此通常将链式队列设计成一个带头结点的单链表，实现插入和删除相统一。带头结点和不带头结点的链式队列如下图所示：</p>\n<p><strong>优点：用单链表表示的链式队列特别适合于数据元素变动比较大的情形，而且不存在队列满且产生溢出的问题。</strong></p>\n<h3 id=\"2-链式队列的基本操作\"><a href=\"#2-链式队列的基本操作\" class=\"headerlink\" title=\"2.链式队列的基本操作\"></a>2.链式队列的基本操作</h3><p>（1）初始化</p>\n<pre><code> void InitQueue(LinkQueue &amp;Q)&#123;\n    Q.front = Q.rear = (LinkNode *)malloc(sizeof(LinkNode));//建立头结点\n    Q.front-&gt;next =NULL; //初始为空\n</code></pre>\n<p>（2）判队空</p>\n<pre><code> bool IsEmpty(LinkQueue Q)&#123;\n    if(Q.front == Q.rear) \n       return true;\n    else\n       return false;\n &#125;\n</code></pre>\n<p>（3）入队</p>\n<pre><code> void EnQueue(LinkQueue &amp;Q，ElemTyepe x)&#123;\n    LinkNode *s=(LinkNode *)malloc(sizeof(LinkNode));\n    s-&gt;data=x; //创建新结点，插入到链尾\n    s-&gt;next=null;\n    Q.rear-&gt;next=s;\n    Q.rear=s;\n &#125;\n</code></pre>\n<p>（4）出队</p>\n<pre><code> bool DeQueue(LinkQueue &amp;Q,ElemType &amp;x)&#123;\n    if(Q.front==Q.rear) //空队\n       return false;\n    LinkNode *p =Q.front-&gt;next;\n    x=p-&gt;data;\n    Q.front-&gt;next=p-&gt;next;\n    if(Q.rear==p)\n       Q.rear=Q.front;//若原队列中只有一个结点，删除后变空\n    free(p);\n    return true;\n &#125;\n</code></pre>\n<h3 id=\"3-链队列示例代码\"><a href=\"#3-链队列示例代码\" class=\"headerlink\" title=\"3.链队列示例代码\"></a>3.链队列示例代码</h3><p>链队列的操作：链队列的初始化、入链队列、链队列队头元素出链队列以及显示链队列所有数据元素的示例代码如下所示：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> OK 1;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ERROR 0;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">int</span> QElemType;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">int</span> Status;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">QNode</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\tQElemType data;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">QNode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125;QNode,*QueuePtr;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> </span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\tQueuePtr rear;</span><br><span class=\"line\">\tQueuePtr front;</span><br><span class=\"line\">&#125;LinkQueue;</span><br><span class=\"line\"></span><br><span class=\"line\">Status <span class=\"title function_\">InitQueue</span><span class=\"params\">(LinkQueue &amp;Q)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tQ.front=Q.rear=(QueuePtr)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(QNode));</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!Q.front)</span><br><span class=\"line\">\t\t<span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tQ.front-&gt;next=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Status <span class=\"title function_\">EnQueue</span><span class=\"params\">(LinkQueue &amp;Q,QElemType e)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tQueuePtr p;</span><br><span class=\"line\">\tp=(QueuePtr)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(QNode));</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(!p)</span><br><span class=\"line\">\t\t<span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">\tp-&gt;data=e;</span><br><span class=\"line\">\tp-&gt;next=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\tQ.rear-&gt;next=p;</span><br><span class=\"line\">\tQ.rear=p;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Status <span class=\"title function_\">displayQueue</span><span class=\"params\">(LinkQueue &amp;Q)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tQueuePtr rear,front;</span><br><span class=\"line\">\tfront=Q.front-&gt;next;</span><br><span class=\"line\">\trear=Q.rear;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(front==rear)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;链队列为空!&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(front!=<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\t&quot;</span>,front-&gt;data);</span><br><span class=\"line\">\t\tfront=front-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Status <span class=\"title function_\">distoryQueue</span><span class=\"params\">(LinkQueue &amp;Q)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(Q.front!=<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tQ.rear=Q.front-&gt;next;</span><br><span class=\"line\">\t\t<span class=\"built_in\">free</span>(Q.front);</span><br><span class=\"line\">\t\tQ.front=Q.rear;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Status <span class=\"title function_\">DeQueue</span><span class=\"params\">(LinkQueue &amp;Q,QElemType &amp;e)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tQueuePtr p;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(Q.front==Q.rear)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ERROR;</span><br><span class=\"line\">\tp=Q.front-&gt;next;</span><br><span class=\"line\">\te=p-&gt;data;</span><br><span class=\"line\">\tQ.front-&gt;next=p-&gt;next;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(Q.rear==p)</span><br><span class=\"line\">\t\tQ.rear=Q.front;</span><br><span class=\"line\">\t<span class=\"built_in\">free</span>(p);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tLinkQueue Q;</span><br><span class=\"line\">\tInitQueue(Q);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;链队列中输入三个数据:\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;10\\t20\\t30&quot;</span>);</span><br><span class=\"line\">\tEnQueue(Q,<span class=\"number\">10</span>);</span><br><span class=\"line\">\tEnQueue(Q,<span class=\"number\">20</span>);</span><br><span class=\"line\">\tEnQueue(Q,<span class=\"number\">30</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n输出链队列中的三个数据:\\n&quot;</span>);</span><br><span class=\"line\">\tdisplayQueue(Q);</span><br><span class=\"line\">\t<span class=\"type\">int</span> e;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;链队列对头元素出队:&quot;</span>);</span><br><span class=\"line\">\tDeQueue(Q,e);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;出队的元素为:e=%d\\n\\n&quot;</span>,e);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;初始化链队列:\\n\\n&quot;</span>);</span><br><span class=\"line\">\tdistoryQueue(Q);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果：</p>\n<p><img data-src=\"https://cdn.jsdelivr.net/gh/chulianyuang/imap/202305231747688.png\" alt=\"在这里插入图片描述\"></p>\n",
            "tags": [
                "栈和队列"
            ]
        },
        {
            "id": "http://example.com/2023/04/23/%E6%A0%88/",
            "url": "http://example.com/2023/04/23/%E6%A0%88/",
            "title": "栈",
            "date_published": "2023-04-23T09:14:32.000Z",
            "content_html": "<h1 id=\"关于栈的那些事\"><a href=\"#关于栈的那些事\" class=\"headerlink\" title=\"关于栈的那些事\"></a>关于栈的那些事</h1><h2 id=\"1-1-栈的基本概念\"><a href=\"#1-1-栈的基本概念\" class=\"headerlink\" title=\"1.1 栈的基本概念\"></a>1.1 栈的基本概念</h2><p>栈：栈是只允许在一端进行插入或删除操作的线性表。栈是一种线性表，但限定了这种线性表只能在某一端进行插入和删除操作。</p>\n<ul>\n<li>栈顶（top）：线性表允许进行插入删除的那一端</li>\n<li>栈底（bottom）：固定的，不允许进行插入和删除的那一端</li>\n<li>空栈：不含任何元素的空表</li>\n</ul>\n<p>栈的特性：后进先出或先进后出。<br>栈的应用：进制转换、<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zby5jc2RuLm5ldC9zby9zZWFyY2g/cT0lRTglQTElQTglRTglQkUlQkUlRTUlQkMlOEYlRTYlQjElODIlRTUlODAlQkMmc3BtPTEwMDEuMjEwMS4zMDAxLjcwMjA=\">表达式求值</span>、括号匹配等。</p>\n<h4 id=\"1-2-栈的顺序存储结构\"><a href=\"#1-2-栈的顺序存储结构\" class=\"headerlink\" title=\"1.2 栈的顺序存储结构\"></a>1.2 栈的顺序存储结构</h4><h5 id=\"1-顺序栈的实现\"><a href=\"#1-顺序栈的实现\" class=\"headerlink\" title=\"1. 顺序栈的实现\"></a>1. 顺序栈的实现</h5><p>采用顺序存储结构的栈称为顺序栈，利用一组地址连续的存储单元存放自栈底到栈顶的数据元素，同时附设一个指针（top）指示当前栈顶元素的位置。</p>\n<p>栈的顺序存储结构类型描述如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MaxSize 50  <span class=\"comment\">//定义栈中元素的最大个数</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">   ElemType data[MaxSize];  <span class=\"comment\">//存放栈中元素</span></span><br><span class=\"line\">   <span class=\"type\">int</span> top;  <span class=\"comment\">//栈顶指针</span></span><br><span class=\"line\">   &#125;SqStack;  </span><br><span class=\"line\"><span class=\"number\">12345</span></span><br></pre></td></tr></table></figure>\n\n<p>栈顶指针：S.top，初始时设置：S.top &#x3D; -1，栈顶元素：S.data[S.top]<br>进栈操作：栈不满时，栈顶指针先加1，再送值到栈顶元素。<br>出栈操作：栈非空时，先去栈顶元素值，再将栈顶指针减1。<br>栈空条件：S.top &#x3D;&#x3D; -1，栈满条件：S.top &#x3D;&#x3D; MaxSize-1，栈长：S.top + 1</p>\n<blockquote>\n<p>注意：顺序栈的入栈操作受数组上界的约束，当对栈的最大使用空间估计不足时，有可能会出现栈上溢出。栈和队列的判空、判断条件，根据实际给的条件不同而变化。</p>\n</blockquote>\n<h5 id=\"2-顺序栈的基本运算\"><a href=\"#2-顺序栈的基本运算\" class=\"headerlink\" title=\"2. 顺序栈的基本运算\"></a>2. 顺序栈的基本运算</h5><p>栈顶指针和栈中元素之间的关系如下图所示：<br><img data-src=\"https://cdn.jsdelivr.net/gh/chulianyuang/imap/202305231727786.jpg\" alt=\"0156ba11238cf6aedc3a1d7751241d1\" style=\"zoom: 67%;\" /><br>顺序栈常用的基本运算的代码实现如下所示：<br>(1)初始化</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">     <span class=\"type\">void</span> <span class=\"title function_\">InitStack</span><span class=\"params\">(SqStack &amp;S)</span>&#123;</span><br><span class=\"line\">         S.top = <span class=\"number\">-1</span>;  <span class=\"comment\">//初始化栈顶指针</span></span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"><span class=\"number\">123</span></span><br></pre></td></tr></table></figure>\n\n<p>（2）判栈空</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">     <span class=\"type\">bool</span> <span class=\"title function_\">StackEmpty</span><span class=\"params\">(SqStack S)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(S.top == <span class=\"number\">-1</span>)  <span class=\"comment\">//栈空</span></span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">else</span>  <span class=\"comment\">//栈非空</span></span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"><span class=\"number\">123456</span></span><br></pre></td></tr></table></figure>\n\n<p>（3）进栈</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">     <span class=\"type\">bool</span> <span class=\"title function_\">Push</span><span class=\"params\">(SqStack &amp;S,ElemType x)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(S.top == MaxSize<span class=\"number\">-1</span>) <span class=\"comment\">//栈满，报错</span></span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        S.data[++S.top] = x;  <span class=\"comment\">//指针先加1，再入栈</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"number\">123456</span></span><br></pre></td></tr></table></figure>\n\n<p>（4）出栈</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">     <span class=\"type\">bool</span> <span class=\"title function_\">Pop</span><span class=\"params\">(SqStack &amp;S,ElemType &amp;x)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(S.top == <span class=\"number\">-1</span>) <span class=\"comment\">//栈空，报错</span></span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">        x = S.data[S.top--];  <span class=\"comment\">//先出栈，指针再减1</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"number\">123456</span></span><br></pre></td></tr></table></figure>\n\n<p>（5）读栈顶元素</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">      <span class=\"type\">bool</span> <span class=\"title function_\">GetTop</span><span class=\"params\">(SqStack S,ElemType x)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(S.top == <span class=\"number\">-1</span>) <span class=\"comment\">//栈空，报错</span></span><br><span class=\"line\">           <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">         x = S.data[S.top];  <span class=\"comment\">// x 记录栈顶元素</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"number\">123456</span></span><br></pre></td></tr></table></figure>\n\n<p>仅为读取栈顶元素，并没有出栈操作，原栈顶元素依然保留在栈中。</p>\n<blockquote>\n<p>注意：栈顶指针初始化为 S.top &#x3D; -1，top 指向的是栈顶元素，进栈操作为 S.data[++S.top] &#x3D; x，出栈操作为 x &#x3D; S.data[S.top– ]。若栈顶指针初始化为 S.top &#x3D; 0，即 top 指向栈顶元素的下一个位置，则入栈操作变为 S.data[S.top++] &#x3D; x，出栈操作变为 x &#x3D; S.data[- -S.top ]。相应的栈空、栈满条件也会发生变化。</p>\n</blockquote>\n<h5 id=\"4-顺序栈示例代码\"><a href=\"#4-顺序栈示例代码\" class=\"headerlink\" title=\"4. 顺序栈示例代码\"></a>4. 顺序栈示例代码</h5><p>1、顺序栈的基本操作：顺序栈的初始化及其栈的入栈、出栈、查看栈中所有元素的示例代码如下所示：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> OK 1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ERROR 0</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> INFEASIBLE -1</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> OVERFLOW -2</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> STACK_INIT_SIZE 100  </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> STACKINCREMENT 10    </span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">int</span> Status;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">int</span> SElemType;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">    SElemType *base; </span><br><span class=\"line\">    SElemType *top;  </span><br><span class=\"line\">    <span class=\"type\">int</span> stacksize;  </span><br><span class=\"line\">&#125;SqStack;</span><br><span class=\"line\">Status <span class=\"title function_\">InitStack</span><span class=\"params\">(SqStack &amp;S)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    S.base = (SElemType *)<span class=\"built_in\">malloc</span>(STACK_INIT_SIZE*<span class=\"keyword\">sizeof</span>(SElemType));</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!S.base)</span><br><span class=\"line\">\t\t<span class=\"built_in\">exit</span>(OVERFLOW); </span><br><span class=\"line\">    S.top = S.base;</span><br><span class=\"line\">    S.stacksize = STACK_INIT_SIZE;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Status <span class=\"title function_\">DestroyStack</span><span class=\"params\">(SqStack &amp;S)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(!S.base)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;不存在该栈\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">free</span>(S.base);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Status <span class=\"title function_\">GetTop</span><span class=\"params\">(SqStack S,SElemType &amp;e)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(S.top == S.base) <span class=\"keyword\">return</span> ERROR;</span><br><span class=\"line\">    e = *(S.top - <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Status <span class=\"title function_\">Push</span><span class=\"params\">(SqStack &amp;S,SElemType e)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(S.top - S.base &gt;= S.stacksize)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        S.base = (SElemType*)<span class=\"built_in\">realloc</span>(S.base,(S.stacksize + STACKINCREMENT)*<span class=\"keyword\">sizeof</span>(SElemType));</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!S.base) </span><br><span class=\"line\">\t\t\t<span class=\"built_in\">exit</span>(OVERFLOW);</span><br><span class=\"line\">        S.top = S.base + S.stacksize;</span><br><span class=\"line\">        S.stacksize += STACKINCREMENT;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    *S.top++ = e;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Status <span class=\"title function_\">Pop</span><span class=\"params\">(SqStack &amp;S,SElemType &amp;e)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(S.top == S.base) <span class=\"keyword\">return</span> ERROR;</span><br><span class=\"line\">    e = * --S.top;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Status <span class=\"title function_\">displayStack</span><span class=\"params\">(SqStack S)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(S.top == S.base)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;该栈为空\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(;S.top != S.base;)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\t&quot;</span>,*(--S.top));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    SqStack S;</span><br><span class=\"line\">    <span class=\"type\">int</span> e;</span><br><span class=\"line\">    InitStack(S);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;数据入栈:\\n&quot;</span>);</span><br><span class=\"line\">    Push(S,<span class=\"number\">10</span>);</span><br><span class=\"line\">    Push(S,<span class=\"number\">20</span>);</span><br><span class=\"line\">    Push(S,<span class=\"number\">30</span>);</span><br><span class=\"line\">\tdisplayStack(S);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;显示栈中的数据:\\n&quot;</span>);</span><br><span class=\"line\">    displayStack(S);</span><br><span class=\"line\">    GetTop(S,e);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;栈顶的元素是:\\n%d\\n&quot;</span>,e);</span><br><span class=\"line\">    Pop(S,e);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;栈顶元素出栈:\\n%d\\n&quot;</span>,e);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;显示栈中的数据:\\n&quot;</span>);</span><br><span class=\"line\">    displayStack(S);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下图所示：<br><img data-src=\"https://img-blog.csdnimg.cn/20210502084535554.png#pic_center\" alt=\"在这里插入图片描述\"><br>2、顺序栈的应用：实现两个多项式的相加运算。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span>  </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdlib.h&gt;</span>   </span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">int</span> ElemType;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">PolynNode</span>&#123;</span>  </span><br><span class=\"line\">    <span class=\"type\">int</span> coef; </span><br><span class=\"line\">    <span class=\"type\">int</span> expn; </span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">PolynNode</span> *<span class=\"title\">next</span>;</span>  </span><br><span class=\"line\">&#125;PolynNode,*PolynList;  </span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">CreatePolyn</span><span class=\"params\">(PolynList &amp;L,<span class=\"type\">int</span> n)</span>  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    <span class=\"type\">int</span> i;  </span><br><span class=\"line\">    PolynList p,q;  </span><br><span class=\"line\">    L=(PolynList)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(PolynNode));</span><br><span class=\"line\">    L-&gt;next=<span class=\"literal\">NULL</span>;  </span><br><span class=\"line\">    q=L;  </span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;成对输入%d个数据\\n&quot;</span>,n);  </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>;i&lt;=n;i++)  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        p=(PolynList)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(PolynNode));  </span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d%d&quot;</span>,&amp;p-&gt;coef,&amp;p-&gt;expn);   </span><br><span class=\"line\">        q-&gt;next=p;  </span><br><span class=\"line\">        q=q-&gt;next;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    p-&gt;next=<span class=\"literal\">NULL</span>;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">PolynTraverse</span><span class=\"params\">(PolynList L,<span class=\"type\">void</span>(*vi)(ElemType, ElemType))</span>  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    PolynList p=L-&gt;next;  </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p)  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        vi(p-&gt;coef, p-&gt;expn);  </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(p-&gt;next)  </span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">&quot; + &quot;</span>);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        p=p-&gt;next;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">visit</span><span class=\"params\">(ElemType c, ElemType e)</span>   </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">if</span>(c != <span class=\"number\">0</span>)  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%dX^%d&quot;</span>,c,e);  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">PolynList <span class=\"title function_\">MergeList</span><span class=\"params\">(PolynList La, PolynList Lb)</span>  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    PolynList pa, pb, pc, Lc;  </span><br><span class=\"line\">    pa = La-&gt;next;  </span><br><span class=\"line\">    pb = Lb-&gt;next;  </span><br><span class=\"line\">    Lc = pc = La;   </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(pa&amp;&amp;pb)  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">if</span>(pa-&gt;expn &lt; pb-&gt;expn)          </span><br><span class=\"line\">        &#123;                                </span><br><span class=\"line\">            pc-&gt;next = pa;             </span><br><span class=\"line\">            pc = pa;  </span><br><span class=\"line\">            pa = pa-&gt;next;             </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pa -&gt;expn &gt; pb-&gt;expn )      </span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">            pc-&gt;next = pb;                </span><br><span class=\"line\">            pc = pb;  </span><br><span class=\"line\">            pb = pb-&gt;next;               </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">else</span>  </span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">            pa-&gt;coef = pa-&gt;coef + pb-&gt;coef;      </span><br><span class=\"line\">            pc-&gt;next = pa;  </span><br><span class=\"line\">            pc = pa;  </span><br><span class=\"line\">            pa = pa-&gt;next;             </span><br><span class=\"line\">            pb = pb-&gt;next;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">   </span><br><span class=\"line\">    pc-&gt;next = pa ? pa:pb;  </span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"keyword\">return</span> Lc;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\">   </span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">main</span><span class=\"params\">()</span>  </span><br><span class=\"line\">&#123;  </span><br><span class=\"line\">    PolynList ha,hb,hc;  </span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;非递减输入多项式A， &quot;</span>);  </span><br><span class=\"line\">    CreatePolyn(ha,<span class=\"number\">5</span>);   </span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;非递减输入多项式B， &quot;</span>);  </span><br><span class=\"line\">    CreatePolyn(hb,<span class=\"number\">5</span>);    </span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;多项式A :&quot;</span>);  </span><br><span class=\"line\">    PolynTraverse(ha, visit);  </span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);  </span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;多项式B :&quot;</span>);  </span><br><span class=\"line\">    PolynTraverse(hb, visit);  </span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);  </span><br><span class=\"line\">   </span><br><span class=\"line\">    hc = MergeList(ha,hb);  </span><br><span class=\"line\">    PolynTraverse(hc, visit);  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><img data-src=\"https://img-blog.csdnimg.cn/20210502090607831.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h4 id=\"1-3-栈的链式存储结构\"><a href=\"#1-3-栈的链式存储结构\" class=\"headerlink\" title=\"1.3 栈的链式存储结构\"></a>1.3 栈的链式存储结构</h4><p>采用链式存储结构的栈称为链栈，链栈的优点是便于多个栈共享存储空间和提高其效率，且不存在栈满上溢的情况。通常采用单链表实现，并规定所有操作都在单链表的表头进行。规定链栈没有头结点，LHead 指向栈顶元素，栈的链式存储结构如下图所示：<br><img data-src=\"https://img-blog.csdnimg.cn/20210502085037626.png#pic_center\" alt=\"在这里插入图片描述\"><br>栈的链式存储结构类型描述如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Linknode</span>&#123;</span></span><br><span class=\"line\">   ElemType data;  <span class=\"comment\">//数据域</span></span><br><span class=\"line\">   <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Linknode</span> *<span class=\"title\">next</span>;</span>  <span class=\"comment\">//指针域</span></span><br><span class=\"line\">&#125;*LiStack;  <span class=\"comment\">//栈定义类型</span></span><br></pre></td></tr></table></figure>\n\n<p>采用链式存储，便于结点的插入和删除。链栈的操作和链表类似，入栈和出栈的操作都在链表的表头进行。对于带头结点和不带头结点的连载，具体的实现会有所不同。</p>\n<p>示例代码：链栈的初始化、入链栈、获取链栈顶元素以及输出链栈所有元素的代码如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> OK 1;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> ERROR 0;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> TRUE 1;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> FALSE 0;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">int</span> Status;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"type\">int</span> ElemType;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkNode</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\tElemType data;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">LinkNode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125;*LiStack;</span><br><span class=\"line\"></span><br><span class=\"line\">Status <span class=\"title function_\">InitStack</span><span class=\"params\">(LiStack &amp;L)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tL=(<span class=\"keyword\">struct</span> LinkNode *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(LinkNode));</span><br><span class=\"line\">\tL-&gt;next=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Status <span class=\"title function_\">InputStack</span><span class=\"params\">(LiStack &amp;L,ElemType e)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tLiStack p;</span><br><span class=\"line\">\tp=(<span class=\"keyword\">struct</span> LinkNode *)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(LinkNode));</span><br><span class=\"line\">\tp-&gt;data=e;</span><br><span class=\"line\">\tp-&gt;next=L-&gt;next;</span><br><span class=\"line\">\tL-&gt;next=p;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Status <span class=\"title function_\">PrintStack</span><span class=\"params\">(LiStack &amp;L)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tLiStack p=L-&gt;next;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(p!=<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\t&quot;</span>,p-&gt;data);</span><br><span class=\"line\">\t\tp=p-&gt;next;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Status <span class=\"title function_\">DestoryStack</span><span class=\"params\">(LiStack &amp;L)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tLiStack p;</span><br><span class=\"line\">\tp=L-&gt;next;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(!p)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tp=p-&gt;next;</span><br><span class=\"line\">\t\t<span class=\"built_in\">free</span>(p);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Status <span class=\"title function_\">GetTop</span><span class=\"params\">(LiStack &amp;L,ElemType &amp;e)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tLiStack p=L-&gt;next;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(p==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ERROR;</span><br><span class=\"line\">\te=p-&gt;data;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tLiStack L;</span><br><span class=\"line\">\t<span class=\"type\">int</span> e;</span><br><span class=\"line\">\t<span class=\"type\">int</span> e1,e2,e3;</span><br><span class=\"line\">\tInitStack(L);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;输入三个数据进入链栈&quot;</span>);</span><br><span class=\"line\">\tInputStack(L,<span class=\"number\">10</span>);</span><br><span class=\"line\">\tInputStack(L,<span class=\"number\">20</span>);</span><br><span class=\"line\">\tInputStack(L,<span class=\"number\">30</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n链栈中的数据为:\\n&quot;</span>);</span><br><span class=\"line\">\tPrintStack(L);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;获取栈顶数据:\\n&quot;</span>);</span><br><span class=\"line\">\tGetTop(L,e);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;栈顶数据为e=%d\\n&quot;</span>,e);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n输出链栈中全部数据:\\n&quot;</span>);</span><br><span class=\"line\">\tPrintStack(L);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n初始化链栈:\\n&quot;</span>);</span><br><span class=\"line\">\tDestoryStack(L);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n&quot;</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果如下图所示：<br><img data-src=\"https://img-blog.csdnimg.cn/2021050208571272.png#pic_center\" alt=\"在这里插入图片描述\"></p>\n",
            "tags": [
                "栈和队列"
            ]
        },
        {
            "id": "http://example.com/2023/03/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%B9%A0%E9%A2%98/",
            "url": "http://example.com/2023/03/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%B9%A0%E9%A2%98/",
            "title": "数据结构第二章线性表习题",
            "date_published": "2023-03-20T15:48:48.000Z",
            "content_html": "<h1 id=\"1-将两个递增的有序链表合并为一个递增的有序链表。要求结果链表仍使用原来两个链表的存储空间，不另外占用其他的存储空间。表中不允许有重复数据\"><a href=\"#1-将两个递增的有序链表合并为一个递增的有序链表。要求结果链表仍使用原来两个链表的存储空间，不另外占用其他的存储空间。表中不允许有重复数据\" class=\"headerlink\" title=\"1.将两个递增的有序链表合并为一个递增的有序链表。要求结果链表仍使用原来两个链表的存储空间，不另外占用其他的存储空间。表中不允许有重复数据\"></a>1.将两个递增的有序链表合并为一个递增的有序链表。要求结果链表仍使用原来两个链表的存储空间，不另外占用其他的存储空间。表中不允许有重复数据</h1><h2 id=\"代码如下：\"><a href=\"#代码如下：\" class=\"headerlink\" title=\"代码如下：\"></a>代码如下：</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;malloc.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*将两个递增的有序链表合并为一个递增的有序链表。要求结果链表仍使用原来两个链表的存储空间，不另外占用其它其它的存储空间。表中不允许有重复数据 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> date;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125;Linklist;</span><br><span class=\"line\"><span class=\"comment\">//构造头节点</span></span><br><span class=\"line\">Linklist* <span class=\"title function_\">toujiedian</span><span class=\"params\">(Linklist *L)</span></span><br><span class=\"line\">&#123; </span><br><span class=\"line\">\tL=(Linklist*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(Linklist));</span><br><span class=\"line\">\tL-&gt;next=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> L;</span><br><span class=\"line\"></span><br><span class=\"line\"> &#125; </span><br><span class=\"line\"> Linklist* <span class=\"title function_\">chushihualianbiao</span> <span class=\"params\">(<span class=\"type\">int</span> e)</span></span><br><span class=\"line\"> &#123;</span><br><span class=\"line\"> \t<span class=\"type\">int</span> d=<span class=\"number\">1</span>,r;</span><br><span class=\"line\"> \tLinklist *L=toujiedian(L),*a,*b;</span><br><span class=\"line\"> \ta=L;</span><br><span class=\"line\"> \t<span class=\"type\">int</span> i;</span><br><span class=\"line\"> \t<span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;e;i++,d++)</span><br><span class=\"line\"> \t&#123;</span><br><span class=\"line\"> \t\tb=(Linklist*)<span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(Linklist));</span><br><span class=\"line\"> \t\t</span><br><span class=\"line\"> \t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;输入第%d个数&quot;</span>,d);</span><br><span class=\"line\"> \t\t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;r);</span><br><span class=\"line\"> \t\tb-&gt;date=r;</span><br><span class=\"line\"> \t\tb-&gt;next=<span class=\"literal\">NULL</span>;</span><br><span class=\"line\"> \t\ta-&gt;next=b;<span class=\"comment\">//这里别接错线 </span></span><br><span class=\"line\"> \t\ta=a-&gt;next;</span><br><span class=\"line\"></span><br><span class=\"line\">\t &#125;</span><br><span class=\"line\">\t </span><br><span class=\"line\"> \t<span class=\"keyword\">return</span> L;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"type\">void</span> <span class=\"title function_\">spelling</span><span class=\"params\">(Linklist *L)</span></span><br><span class=\"line\"> &#123;</span><br><span class=\"line\"> \tLinklist *a;</span><br><span class=\"line\"> \ta=L-&gt;next;</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;你输入的链表为：\\n&quot;</span>);</span><br><span class=\"line\"> \t<span class=\"keyword\">while</span>(a)</span><br><span class=\"line\">\t &#123;</span><br><span class=\"line\"> \t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\t&quot;</span>,a-&gt;date);</span><br><span class=\"line\"> \t\ta=a-&gt;next;</span><br><span class=\"line\">\t &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Linklist* <span class=\"title function_\">MergeList</span><span class=\"params\">(Linklist *La,Linklist *Lb)</span></span><br><span class=\"line\"> </span><br><span class=\"line\">\t&#123;<span class=\"comment\">//合并链表La和Lb，合并后的新表使用头指针Lc指向</span></span><br><span class=\"line\">\tLinklist *Lc;</span><br><span class=\"line\">    Linklist *pa,*pb,*pc,*q;</span><br><span class=\"line\">\t  pa=La-&gt;next; pb=Lb-&gt;next;   </span><br><span class=\"line\"> </span><br><span class=\"line\">\t  <span class=\"comment\">//pa和pb分别是链表La和Lb的工作指针,初始化为相应链表的第一个结点</span></span><br><span class=\"line\"> </span><br><span class=\"line\">\t  Lc=pc=La; <span class=\"comment\">//用La的头结点作为Lc的头结点</span></span><br><span class=\"line\"> </span><br><span class=\"line\">\t  <span class=\"keyword\">while</span>(pa &amp;&amp; pb)</span><br><span class=\"line\"> </span><br><span class=\"line\">\t&#123;<span class=\"keyword\">if</span>(pa-&gt;date&lt;pb-&gt;date)&#123;pc-&gt;next=pa;pc=pa;pa=pa-&gt;next;&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t    <span class=\"comment\">//取较小者La中的元素，将pa链接在pc的后面，pa指针后移</span></span><br><span class=\"line\"> </span><br><span class=\"line\">\t    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(pa-&gt;date&gt;pb-&gt;date) &#123;pc-&gt;next=pb; pc=pb; pb=pb-&gt;next;&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t     <span class=\"comment\">//取较小者Lb中的元素，将pb链接在pc的后面，pb指针后移</span></span><br><span class=\"line\"> </span><br><span class=\"line\">\t    <span class=\"keyword\">else</span> <span class=\"comment\">//相等时取La中的元素，删除Lb中的元素</span></span><br><span class=\"line\"> </span><br><span class=\"line\">\t    &#123;     pc-&gt;next=pa;pc=pa;pa=pa-&gt;next;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t          q=pb-&gt;next;<span class=\"built_in\">free</span> (pb) ;pb =q;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">\t pc-&gt;next=pa?pa:pb;   <span class=\"comment\">//插入剩余段</span></span><br><span class=\"line\"> </span><br><span class=\"line\">\t    <span class=\"built_in\">free</span> (Lb);           <span class=\"comment\">//释放Lb的头结点</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> Lc;</span><br><span class=\"line\">\t&#125; </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> </span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t   Linklist *L;</span><br><span class=\"line\">\t   <span class=\"type\">int</span> e; </span><br><span class=\"line\">    toujiedian(L);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;输入第一个递增链表长度&quot;</span>);</span><br><span class=\"line\">   \t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;e) ;</span><br><span class=\"line\">    L=chushihualianbiao (e);</span><br><span class=\"line\">    spelling(L);</span><br><span class=\"line\">    Linklist *P,*O;</span><br><span class=\"line\">    <span class=\"type\">int</span> k; </span><br><span class=\"line\">    toujiedian(P);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n输入第二个递增链表长度&quot;</span>);</span><br><span class=\"line\">   \t<span class=\"built_in\">scanf</span>(<span class=\"string\">&quot;%d&quot;</span>,&amp;k) ;</span><br><span class=\"line\">    P=chushihualianbiao (k);</span><br><span class=\"line\">    spelling(P);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n两个链表合成后为:\\n&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">//O=lianbiaoronghe(L,P );</span></span><br><span class=\"line\">    O=MergeList(L,P);</span><br><span class=\"line\">    spelling(O);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n",
            "tags": [
                "习题答案"
            ]
        },
        {
            "id": "http://example.com/2023/03/10/ElemType%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/",
            "url": "http://example.com/2023/03/10/ElemType%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/",
            "title": "ElemType是什么？",
            "date_published": "2023-03-09T23:32:22.000Z",
            "content_html": "<p>在定义结构体array的时候有这样一段：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">   ElemType data[maxsize];</span><br><span class=\"line\">   <span class=\"type\">int</span> length;</span><br><span class=\"line\">&#125; <span class=\"built_in\">array</span>;</span><br></pre></td></tr></table></figure>\n\n<p>在《数据结构》中，关于数据元素的类型定义均用“ ElemType e；”来表示，其中e是表示数据元素的变量，而ElemType则是它的类型，ElemType的含义就是“数据元素的类型”，是一个抽象的概念，是表示我们所要使用的数据元素应有的类型。</p>\n<p><strong>使用：typedef int ElemType;&#x2F;&#x2F;定义ElemType为int类型<br>你想让它是什么类型自己用typedef重定义就行。<br>也可以用模板表示，类似template<class T>里面的T。</strong></p>\n<p>这对于初学数据结构的学生来说理解起来有些难度，为了利于理解，我们可以把”ElemType“等同于”一套房子“来理解：<br>“一套房子”的含义大家都非常清楚，但一套房子的具体含义是因人而异的，有的认为是“四室二厅”，有的认为是“二室一厅”，也有的认为是“一室一厅”，对此大家也没有任何异议！其实ElemType也是这样的，它有时表示“整型”，有时表示“用户自定义的结构体”，也可以是其他形式的类型自由表示！</p>\n",
            "tags": [
                "细解"
            ]
        },
        {
            "id": "http://example.com/2023/03/09/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E4%B8%AD%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0/",
            "url": "http://example.com/2023/03/09/%E9%A1%BA%E5%BA%8F%E8%A1%A8%E4%B8%AD%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0/",
            "title": "顺序表中基本操作的实现",
            "date_published": "2023-03-09T13:06:54.000Z",
            "content_html": "<h1 id=\"顺序表中基本操作的实现\"><a href=\"#顺序表中基本操作的实现\" class=\"headerlink\" title=\"顺序表中基本操作的实现\"></a>顺序表中基本操作的实现</h1><p>线性表的顺序表示指的是用一组地址连续的存储单元依次存储线性表的数据元素，这种表示也称作线性表的顺序存储结构或顺序映像。通常，称这种存储结构的线性表为<strong>顺序表</strong>。起特点是，逻辑上相邻的数据元素，其物理次序也是相邻的。</p>\n<p>线性表的每一个数据元素的存储位置都和线性表的起始位置相差一个常数，这个常数和数据元素在线性表中的位序成正比。由此，只要确定了存储线性表的起始位置，线性表中任一数据元素都可随机存取，所以线性表的顺序存储结构是一种<strong>随机存取</strong>的存储结构。</p>\n<p>由于线性表的长度可变，且所需最大存储空间随问题不同而不同，则在C语言中可用动态分配的一维数组来表示线性表，格式如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//顺序表的存储结构</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MAXISIZE 100 <span class=\"comment\">//顺序表可能达到的最大长度</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\tElemType* elem;<span class=\"comment\">//等同于ElemType elem[MAXISIZE]</span></span><br><span class=\"line\">\t<span class=\"type\">int</span> length;<span class=\"comment\">//当前长度</span></span><br><span class=\"line\">&#125;sqlist;</span><br></pre></td></tr></table></figure>\n<p><strong>注意</strong></p>\n<ol>\n<li><strong>数组空间通过后面算法初始化动态分配得到，初始化完成后，数组指针elem指示顺序表的基地址，数组空间大小为MAXSIZE。</strong></li>\n<li><strong>元素类型定义中的ElemType数据类型是为了描述统一而自定的，在实际应用中，用户可根据实际需要具体定义表中数据元素的数据类型，可以是基本数据类型，如int ,float ,char 等，也可以是构造数据类型，如struct结构体类型。</strong></li>\n<li><strong>length表示顺序表中当前数据元素的个数。</strong></li>\n</ol>\n<p><strong>线性表初始化，取值，查找，插入，删除的完整代码</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MAXSIZE 100</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> OVERFLOW 0</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span>  ERROR 0</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> OK 1</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"type\">int</span>* elem;</span><br><span class=\"line\">\t<span class=\"type\">int</span> length;</span><br><span class=\"line\">&#125;SqList;</span><br><span class=\"line\"><span class=\"comment\">//初始化</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">InitList</span><span class=\"params\">(SqList&amp; L)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tL.elem = new <span class=\"type\">int</span>[MAXSIZE];</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!L.elem) <span class=\"built_in\">exit</span> (OVERFLOW);</span><br><span class=\"line\">\tL.length = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//取值</span></span><br><span class=\"line\"><span class=\"type\">char</span> <span class=\"title function_\">GetElem</span><span class=\"params\">(SqList L, <span class=\"type\">int</span> i, <span class=\"type\">int</span> e)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (i&lt;<span class=\"number\">1</span> || i&gt;L.length) <span class=\"keyword\">return</span> ERROR;</span><br><span class=\"line\">\te = L.elem[i - <span class=\"number\">1</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//查找</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">LocateElem</span><span class=\"params\">(SqList L, <span class=\"type\">int</span> e)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> i;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>;i &lt; L.length;i++) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (L.elem[i] == e)<span class=\"keyword\">return</span> i + <span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//插入</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">ListInsert</span><span class=\"params\">(SqList&amp; L, <span class=\"type\">int</span> i, <span class=\"type\">int</span> e)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> j;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ((i &lt; <span class=\"number\">1</span>) || (i &gt; L.length + <span class=\"number\">1</span>))<span class=\"keyword\">return</span> ERROR;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (L.length == MAXSIZE) <span class=\"keyword\">return</span> ERROR;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (j = L.length - <span class=\"number\">1</span>;j &gt;= i - <span class=\"number\">1</span>;j--)</span><br><span class=\"line\">\t\tL.elem[j + <span class=\"number\">1</span>] = L.elem[j];</span><br><span class=\"line\">\tL.elem[i - <span class=\"number\">1</span>] = e;</span><br><span class=\"line\">\t++L.length;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//删除</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">ListDelete</span><span class=\"params\">(SqList&amp; L, <span class=\"type\">int</span> i)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> j;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ((i &lt; <span class=\"number\">1</span>) || (i &gt; L.length)) <span class=\"keyword\">return</span> ERROR;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> (j = i;j &lt;= L.length - <span class=\"number\">1</span>;j++)</span><br><span class=\"line\">\t\tL.elem[j - <span class=\"number\">1</span>] = L.elem[j];</span><br><span class=\"line\">\t--L.length;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//还没有调用，按需求调用</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n",
            "tags": [
                "知识总结"
            ]
        },
        {
            "id": "http://example.com/2023/03/09/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89/",
            "url": "http://example.com/2023/03/09/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89/",
            "title": "线性表的类型定义",
            "date_published": "2023-03-09T11:54:04.000Z",
            "content_html": "<h1 id=\"线性表的类型定义\"><a href=\"#线性表的类型定义\" class=\"headerlink\" title=\"线性表的类型定义\"></a>线性表的类型定义</h1><p>[TOC]</p>\n<blockquote>\n<p>数据结构三要素—<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zby5jc2RuLm5ldC9zby9zZWFyY2g/cT0lRTklODAlQkIlRTglQkUlOTElRTclQkIlOTMlRTYlOUUlODQmc3BtPTEwMDEuMjEwMS4zMDAxLjcwMjA=\">逻辑结构</span>、数据的运算、存储结构(物理结构)【存储结构不同，运算的实现方式就不同】</p>\n</blockquote>\n<h1 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h1><p>线性表是具有相同数据类型的n(n≥0)个数据元素的有限序列，其中n为表长，当n&#x3D;0时线<br>性表是一个空表。若用命名线性表，则其一般表示为</p>\n<p>L &#x3D; ( a 1 , a 2 , … , a i … , a n L&#x3D;(a_1,a_2,…,a_i…,a_nL&#x3D;(a1,a2,…,ai…,an</p>\n<ol>\n<li>a i a_iai是线性表中的“第i个”元素线性表中的位序</li>\n<li>a 1 a_1a1是表头元素；a n a_nan是表尾元素</li>\n<li>除第一个元素外，每个元素有且仅有一个直接前驱；除最后一个元素外，每个元素有且只有一个直接后继。</li>\n</ol>\n<p><img data-src=\"https://img-blog.csdnimg.cn/826f9cb758e2452281777a889debcf62.png\" alt=\"在这里插入图片描述\"></p>\n<h1 id=\"基本操作\"><a href=\"#基本操作\" class=\"headerlink\" title=\"基本操作\"></a>基本操作</h1><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">InitList(&amp;L)：初始化表。构造一个空的线性表L，分配内存空间。</span><br><span class=\"line\"></span><br><span class=\"line\">DestroyList(&amp;L)：销毁操作。销毁线性表，并释放线性表L所占用的内存空间。</span><br><span class=\"line\"></span><br><span class=\"line\">ListInsert(&amp;L,i,e)：插入操作。在表L中的第i个位置上插入指定元素e。</span><br><span class=\"line\"></span><br><span class=\"line\">ListDelete(&amp;L,i,&amp;e)：删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值。</span><br><span class=\"line\"></span><br><span class=\"line\">LocateElem(L,e)：按值查找操作。在表L中查找具有给定关键字值的元素。</span><br><span class=\"line\"></span><br><span class=\"line\">GetElem(L,i)：按位查找操作。获取表L中第i个位置的元素的值。</span><br><span class=\"line\"></span><br><span class=\"line\">其他常用操作：</span><br><span class=\"line\"></span><br><span class=\"line\">Length(L) 求表长。返回线性表L的长度，即L中数据元素的个数。</span><br><span class=\"line\"></span><br><span class=\"line\">PrintList(L) 输出操作。按前后顺序输出线性表L的所有元素值。</span><br><span class=\"line\"></span><br><span class=\"line\">Empty(L) 判空操作。若L为空表，则返回<span class=\"literal\">true</span>，否则返回<span class=\"literal\">false</span>。</span><br></pre></td></tr></table></figure>\n<p><strong>值得注意的是：</strong></p>\n<ol>\n<li><strong>抽象数据类型仅是一个模型的定义，并不涉及模型的具体实现，因此这里描述中所涉及的参数不必考虑具体数据类型。在实际应用中，数据元素可能有多种类型，我们要随机应变。</strong></li>\n<li><strong>上述抽象数据类型中给出的操作只是基本操作，由这些基本操作可以构成其它较复杂的操作。</strong></li>\n<li><strong>对于不同的应用，基本操作的接口可能不同。</strong></li>\n<li><strong>由抽象数据类型定义的线性表，可以根据实际所采用的存储结构形式，进行具体的表示与实现。</strong></li>\n</ol>\n<p><img data-src=\"https://img-blog.csdnimg.cn/4c48d1a1f52d4f268a1e1112beacda96.png\" alt=\"在这里插入图片描述\"></p>\n<h1 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h1><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * @author five-five</span></span><br><span class=\"line\"><span class=\"comment\"> * @created 2022/5/2</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> INIT_SIZE 10 <span class=\"comment\">//初试长度</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> length;<span class=\"comment\">//顺序表的长度</span></span><br><span class=\"line\">    <span class=\"type\">int</span> *data;<span class=\"comment\">//顺序表的内容</span></span><br><span class=\"line\">    <span class=\"type\">int</span> maxsize;<span class=\"comment\">//顺序表的最大长度</span></span><br><span class=\"line\">&#125; SeqList;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * @param l 线性表指针</span></span><br><span class=\"line\"><span class=\"comment\"> * @return 1:success?fail</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">initList</span><span class=\"params\">(SeqList *l)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">//用malloc函数申请一片连续的存储空间</span></span><br><span class=\"line\">    <span class=\"comment\">//重点掌握为什么需要强转malloc()类型为int*类型</span></span><br><span class=\"line\">    <span class=\"comment\">//指针在移动是会根据sizeof(type)去进行移动，如果你不指定指针的类型，那么在指针移动检索的操作时，指针只会一个一个字节的去移动</span></span><br><span class=\"line\">    l-&gt;data = (<span class=\"type\">int</span> *) <span class=\"built_in\">malloc</span>(INIT_SIZE * <span class=\"keyword\">sizeof</span>(<span class=\"type\">int</span>));</span><br><span class=\"line\">    l-&gt;length = <span class=\"number\">0</span>;</span><br><span class=\"line\">    l-&gt;maxsize = INIT_SIZE;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * @param l 线性表指针</span></span><br><span class=\"line\"><span class=\"comment\"> * @param len 长度</span></span><br><span class=\"line\"><span class=\"comment\"> * @return 1:success?fail</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">increaseSize</span><span class=\"params\">(SeqList *l, <span class=\"type\">int</span> len)</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> *pInt = l-&gt;data;</span><br><span class=\"line\">    l-&gt;data = (<span class=\"type\">int</span> *) <span class=\"built_in\">malloc</span>(l-&gt;maxsize + len * <span class=\"keyword\">sizeof</span>(<span class=\"type\">int</span>));</span><br><span class=\"line\">    <span class=\"comment\">//复制</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; l-&gt;length; ++i) &#123;</span><br><span class=\"line\">        l-&gt;data[i] = pInt[i];<span class=\"comment\">//将数据复制到新区域</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    l-&gt;maxsize = l-&gt;maxsize + len;<span class=\"comment\">//顺序表的最大长度增加len</span></span><br><span class=\"line\">    <span class=\"built_in\">free</span>(pInt);<span class=\"comment\">//释放空间</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * @param l 线性表指针</span></span><br><span class=\"line\"><span class=\"comment\"> * @param i 下标</span></span><br><span class=\"line\"><span class=\"comment\"> * @param e 插入元素</span></span><br><span class=\"line\"><span class=\"comment\"> * @return</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">listInsert</span><span class=\"params\">(SeqList *l, <span class=\"type\">int</span> i, <span class=\"type\">int</span> e)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = l-&gt;length; j &gt;= i; --j) &#123;</span><br><span class=\"line\">        l-&gt;data[j] = l-&gt;data[j - <span class=\"number\">1</span>];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    l-&gt;data[i] = e;</span><br><span class=\"line\">    l-&gt;length++;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * @param l 线性表指针</span></span><br><span class=\"line\"><span class=\"comment\"> * @param i 下标</span></span><br><span class=\"line\"><span class=\"comment\"> * @param e int 指针，用于接收删除值</span></span><br><span class=\"line\"><span class=\"comment\"> * @return</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">listDelete</span><span class=\"params\">(SeqList *l, <span class=\"type\">int</span> i, <span class=\"type\">int</span> *e)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i &lt; <span class=\"number\">1</span> || i &gt; l-&gt;length) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    *e = l-&gt;data[i - <span class=\"number\">1</span>];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> j = i; j &lt; l-&gt;length; j++) &#123;</span><br><span class=\"line\">        l-&gt;data[j - <span class=\"number\">1</span>] = l-&gt;data[j];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    l-&gt;length--;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 取出下标对应的元素</span></span><br><span class=\"line\"><span class=\"comment\"> * @param l 线性表</span></span><br><span class=\"line\"><span class=\"comment\"> * @param i 要去除元素下标</span></span><br><span class=\"line\"><span class=\"comment\"> * @return 下标对应的元素</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">getElem</span><span class=\"params\">(SeqList l, <span class=\"type\">int</span> i)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> l.data[i - <span class=\"number\">1</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 按值查找，并返回下标</span></span><br><span class=\"line\"><span class=\"comment\"> * @param l 线性表</span></span><br><span class=\"line\"><span class=\"comment\"> * @param e 要查找元素值</span></span><br><span class=\"line\"><span class=\"comment\"> * @return -1表示没有找到</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">locateElem</span><span class=\"params\">(SeqList l, <span class=\"type\">int</span> e)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; l.length; ++i) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e == l.data[i]) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> i + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span> &#123;</span><br><span class=\"line\">    SeqList seqList;</span><br><span class=\"line\">    initList(&amp;seqList);</span><br><span class=\"line\">    increaseSize(&amp;seqList, <span class=\"number\">100</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%l&quot;</span>, <span class=\"keyword\">sizeof</span>(seqList));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n",
            "tags": [
                "知识点总结"
            ]
        },
        {
            "id": "http://example.com/2023/03/09/c%E8%AF%AD%E8%A8%80malloc%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95%E5%92%8C%E6%84%8F%E4%B9%89/",
            "url": "http://example.com/2023/03/09/c%E8%AF%AD%E8%A8%80malloc%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95%E5%92%8C%E6%84%8F%E4%B9%89/",
            "title": "c语言malloc函数的用法和意义",
            "date_published": "2023-03-09T08:58:16.000Z",
            "content_html": "<p>当我们需要做一个成绩管理系统，人数可能为全校学生，也可能为一个班的学生，当我们开辟一个班的数组大小时，如果要存储整个学校的人数时，会出现内存不够用的情况；当我们开辟全校人数大小的数组时，输入一个班人数的大小时，会出现内存浪费的情况。<br>为了应对上述问题，我们引入<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zby5jc2RuLm5ldC9zby9zZWFyY2g/cT1tYWxsb2Mmc3BtPTEwMDEuMjEwMS4zMDAxLjcwMjA=\">malloc</span>函数。<br><strong>malloc时动态内存分配函数，用于申请一块连续的指定大小的内存块区域以void*类型返回分配的内存区域地址</strong></p>\n<h2 id=\"malloc函数原型\"><a href=\"#malloc函数原型\" class=\"headerlink\" title=\"malloc函数原型\"></a>malloc函数原型</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">extern void *malloc(unsigned int num_bytes);</span><br><span class=\"line\">1</span><br></pre></td></tr></table></figure>\n\n<p>意为分配长度为num_bytes字节的内存块</p>\n<h2 id=\"malloc函数头文件\"><a href=\"#malloc函数头文件\" class=\"headerlink\" title=\"malloc函数头文件\"></a>malloc函数头文件</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include&lt;malloc.h&gt;</span><br><span class=\"line\">1</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"malloc函数返回值\"><a href=\"#malloc函数返回值\" class=\"headerlink\" title=\"malloc函数返回值\"></a>malloc函数返回值</h2><p>如果分配成功则返回指向被分配内存的指针，否则返回空指针NULL。</p>\n<h2 id=\"malloc函数使用注意事项\"><a href=\"#malloc函数使用注意事项\" class=\"headerlink\" title=\"malloc函数使用注意事项\"></a>malloc函数使用注意事项</h2><p>malloc函数的返回的是无类型指针，在使用时一定要强制转换为所需要的类型。<br><strong>（敲黑板）重点：在使用malloc开辟空间时，使用完成一定要释放空间，如果不释放会造内存泄漏。</strong><br><strong>在使用malloc函数开辟的空间中，不要进行指针的移动，因为一旦移动之后可能出现申请的空间和释放空间大小的不匹配</strong></p>\n<h2 id=\"malloc函数使用形式\"><a href=\"#malloc函数使用形式\" class=\"headerlink\" title=\"malloc函数使用形式\"></a>malloc函数使用形式</h2><p>关于malloc所开辟空间类型：malloc只开辟空间，不进行类型检查，只是在使用的时候进行类型的强转。<br>举个例子：‘我’开辟你所需要大小的字节大小空间，至于怎么使用是你的事<br>mallo函数返回的实际是一个无类型指针，必须在其前面加上指针类型强制转换才可以使用<br>指针自身 &#x3D; (指针类型<em>）malloc（sizeof（指针类型）</em>数据数量）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\tint *p = NULL;</span><br><span class=\"line\">\tint n = 10;</span><br><span class=\"line\">\tp = (int *)malloc(sizeof(int)*n);</span><br><span class=\"line\">123</span><br></pre></td></tr></table></figure>\n\n<p>在使用malloc函数之前我们一定要<strong>计算字节数</strong>，malloc开辟的是用户所需求的字节数大小的空间。<br>如果多次申请空间那么系统是如何做到空间的不重复使用呢？<br>在使用malloc开辟一段空间之后，系统会在这段空间之前做一个标记（0或1），当malloc函数开辟空间如果遇到标记为0就在此开辟，如果为1说明此空间正在被使用。</p>\n<h2 id=\"free函数\"><a href=\"#free函数\" class=\"headerlink\" title=\"free函数\"></a>free函数</h2><p>作用：释放malloc(或calloc、realloc)函数给指针变量分配的内存空间。<br>注意：使用后该<strong>指针变量一定要重新指向NULL</strong>，防止悬空指针（失效指针）出现，有效规避错误操作。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int main()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint *p = (int *)malloc(sizeof(int));</span><br><span class=\"line\">\t*p = 100;</span><br><span class=\"line\">\tfree(p);</span><br><span class=\"line\">\tp = NULL;</span><br><span class=\"line\">\treturn 0;</span><br><span class=\"line\">1234567</span><br></pre></td></tr></table></figure>\n\n<p><strong>free函数在释放空间之后，把内存前的标志变为0，且为了防止数据泄露，它会把所释放的空间用cd进行填充。</strong></p>\n",
            "tags": [
                "巧思"
            ]
        },
        {
            "id": "http://example.com/2023/03/07/%E7%BB%AA%E8%AE%BA/",
            "url": "http://example.com/2023/03/07/%E7%BB%AA%E8%AE%BA/",
            "title": "绪论",
            "date_published": "2023-03-07T09:15:42.000Z",
            "content_html": "<h1 id=\"绪论\"><a href=\"#绪论\" class=\"headerlink\" title=\"绪论\"></a>绪论</h1><h2 id=\"树状图总结\"><a href=\"#树状图总结\" class=\"headerlink\" title=\"树状图总结\"></a>树状图总结</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph LR</span><br><span class=\"line\"> </span><br><span class=\"line\">A[绪论] --&gt;B(数据结构)--&gt;C(逻辑结构)--&gt;a(线性结构)--&gt;d&#123;线性表&#125;</span><br><span class=\"line\">a--&gt;q&#123;栈和队列&#125; </span><br><span class=\"line\">a--&gt;w&#123;字符串&#125;</span><br><span class=\"line\">C--&gt;b(非线性结构)--&gt;e&#123;树状图&#125;</span><br><span class=\"line\">b--&gt;r&#123;图结构&#125;</span><br><span class=\"line\">B--&gt;D(存储结构)--&gt;t&#123;顺序存储结构&#125;</span><br><span class=\"line\">D--&gt;y&#123;链式存储结构&#125;</span><br><span class=\"line\">A[绪论] --&gt;c(算法)--&gt;u(定义)</span><br><span class=\"line\">  c--&gt;o(特性)</span><br><span class=\"line\">  c--&gt;p(评价标准)</span><br><span class=\"line\">  c--&gt;s(效率度量)--&gt;f&#123;时间复杂度&#125;</span><br><span class=\"line\">  s--&gt;g&#123;空间复杂度&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">   </span><br></pre></td></tr></table></figure>\n\n<h2 id=\"在这一章中主要介绍了数据结构的基本概念和术语，以及算法和算法时间复杂度的分析方法。\"><a href=\"#在这一章中主要介绍了数据结构的基本概念和术语，以及算法和算法时间复杂度的分析方法。\" class=\"headerlink\" title=\"在这一章中主要介绍了数据结构的基本概念和术语，以及算法和算法时间复杂度的分析方法。\"></a>在这一章中主要介绍了数据结构的基本概念和术语，以及算法和算法时间复杂度的分析方法。</h2><ul>\n<li><p>数据结构是一门研究非数值计算程序设计中操作对象，以及这些对象之间的关系和操作对象，以及这些对象之间的关系和操作的学科。</p>\n</li>\n<li><p>数据结构包括两个方面的内容：数据的逻辑结构和存储结构。同一逻辑结构采用不同的储存方法，可以得到不同的存储结构</p>\n<ol>\n<li>逻辑结构是从具体问题抽象出来的数学模型，从逻辑关系上描述数据，它与数据的存储无关。根据数据元素之间关系的不同特性，通常有四类基本逻辑结构：集合结构，线性结构，树形结构和图状结构。</li>\n<li>存储结构是逻辑结构在计算机中的存储表示，有两类存储结构:顺序粗出结构和链式存储结构。</li>\n</ol>\n</li>\n<li><p>抽象数据类型是指由用户定义的，表示应用问题的数学模型，以及定义在这个模型上的一组操作的总称，具体包括三部分：数据对象，数据对象上关系的集合，以及对数据对象的基本操作的集合。</p>\n</li>\n<li><p>算法是为了解决某类问题而规定的一个有限长的操作数列。算法具有四个特性：正确性，可读性，健壮性和高效性。</p>\n</li>\n<li><p>算法分析的两个主要方面是分析算法的时间发杂度和空间复杂度，以考察算法的时间和空间效率。一般情况下，鉴于运算空间较为充足，故将算法的时间复杂度作为分析的重点。算法执行时间的数量级称为算法的渐近时间复杂度，T(n)&#x3D;O(f(n))，它表示随着问题n的增大，算法执行时间的增长率和f(n)的增长率相同，简称时间复杂度。</p>\n</li>\n</ul>\n<h3 id=\"这一章的知识点并不多，我着重讲一下时间复杂度的相关知识\"><a href=\"#这一章的知识点并不多，我着重讲一下时间复杂度的相关知识\" class=\"headerlink\" title=\"这一章的知识点并不多，我着重讲一下时间复杂度的相关知识\"></a>这一章的知识点并不多，我着重讲一下时间复杂度的相关知识</h3><p>在描述算法复杂度时，经常用到O ( 1 ) , O ( n ) , O ( l o g n ) , O ( n l o g n ) 来表示对应复杂度程度, 不过目前大家默认也通过这几个方式表示<span class=\"exturl\" data-url=\"aHR0cHM6Ly9zby5jc2RuLm5ldC9zby9zZWFyY2g/cT0lRTclQTklQkElRTklOTclQjQlRTUlQTQlOEQlRTYlOUQlODIlRTUlQkElQTYmc3BtPTEwMDEuMjEwMS4zMDAxLjcwMjA=\">空间复杂度</span> 。</p>\n<p>那么，O ( 1 ) , O ( n ) , O ( l o g n ) , O ( n l o g n )就可以看作既可表示算法复杂度，也可以表示空间复杂度。</p>\n<p>大O加上（）的形式，里面其实包裹的是一个函数f ( ) , O （ f ( ) ） f(),O（f()）f(),O（f()）,指明某个算法的耗时&#x2F;耗空间与数据增长量之间的关系。其中的 n  代表输入数据的量。</p>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20200415110541459.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<blockquote>\n<p>如果ax&#x3D;N（a&gt;0，且a≠1），那么数x叫做以a为底N的对数，记作x&#x3D;logaN，读作以a为底N的对数，其中a叫做对数的底数，N叫做真数。</p>\n</blockquote>\n<p><img data-src=\"https://img-blog.csdnimg.cn/20200415110548576.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY5Nzc3NA==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"><br>比如线段树复杂度O ( l o g n + n ) ，查询修改都是O ( l o g n ) <strong>刚学的时候简直惊为天人</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>;i&lt;=n;++i)</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">1</span>;j&lt;=i;++j)</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> k=<span class=\"number\">1</span>;k&lt;=j;++k)</span><br><span class=\"line\">                x=x+<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"number\">1234</span></span><br></pre></td></tr></table></figure>\n\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9zby5jc2RuLm5ldC9zby9zZWFyY2g/cT0lRTYlOTclQjYlRTklOTclQjQlRTUlQTQlOEQlRTYlOUQlODIlRTUlQkElQTYmc3BtPTEwMDEuMjEwMS4zMDAxLjcwMjA=\">时间复杂度</span>是 O(n^3)</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> i=<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i&lt;=n)</span><br><span class=\"line\">        i*=<span class=\"number\">2</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"number\">1234</span></span><br></pre></td></tr></table></figure>\n\n<p>时间复杂度O ( l o g 2 n )−&gt;O ( l o g n )<br>评测机一般能过10^8~10^9 ，根据评测机的性能以及程序的常数而定</p>\n",
            "tags": [
                "知识点总结"
            ]
        }
    ]
}